import deduction lindenbaum

universes u v

namespace fopl

variables (L : language.{u})

local infix ` ‚âÉ‚ÇÅ `:80 := ((‚âÉ) : term L ‚Üí term L ‚Üí formula L)

local prefix `‚àè‚ÇÅ `:64 := (has_univ_quantifier.univ : formula L ‚Üí formula L)

local prefix `‚àê‚ÇÅ `:64 := (has_exists_quantifier.ex : formula L ‚Üí formula L)

structure pnf : Type u := 
(quantifier : list bool)
(p : formula L)
(openform : p.is_open)

local notation `ùö∑` := bool.tt

local notation `ùö∫` := bool.ff

variables {L}



namespace pnf

def fal : pnf L ‚Üí pnf L
| ‚ü®Q, p, h‚ü© := ‚ü®ùö∑ :: Q, p, h‚ü©

def ex : pnf L ‚Üí pnf L
| ‚ü®Q, p, h‚ü© := ‚ü®ùö∫ :: Q, p, h‚ü©

instance : has_univ_quantifier (pnf L) (pnf L) := ‚ü®pnf.fal‚ü©

instance : has_exists_quantifier (pnf L) (pnf L) := ‚ü®pnf.ex‚ü©

@[simp] lemma fal_eq (Q : list bool) (p : formula L) (h) : (‚àè (‚ü®Q, p, h‚ü© : pnf L) : pnf L) = ‚ü®ùö∑ :: Q, p, h‚ü© := rfl

@[simp] lemma ex_eq (Q : list bool) (p : formula L) (h) : (‚àê (‚ü®Q, p, h‚ü© : pnf L) : pnf L) = ‚ü®ùö∫ :: Q, p, h‚ü© := rfl

@[simp] def to_openform : pnf L ‚Üí formula L
| ‚ü®Q, p, h‚ü© := p

@[simp] def to_formula : pnf L ‚Üí formula L
| ‚ü®[], p, h‚ü©     := p
| ‚ü®ùö∑ :: Q, p, h‚ü© := ‚àè to_formula ‚ü®Q, p, h‚ü©
| ‚ü®ùö∫ :: Q, p, h‚ü© := ‚àê to_formula ‚ü®Q, p, h‚ü©

@[simp] def fal_to_formula : ‚àÄ p : pnf L, (‚àè p : pnf L).to_formula = ‚àè p.to_formula
| ‚ü®Q, p, h‚ü©     := by simp

@[simp] def ex_to_formula : ‚àÄ p : pnf L, (‚àê p : pnf L).to_formula = ‚àê p.to_formula
| ‚ü®Q, p, h‚ü©     := by simp

@[simp] def rank : pnf L ‚Üí ‚Ñï := Œª p, p.1.length

def rew (s : ‚Ñï ‚Üí term L) : pnf L ‚Üí pnf L
| ‚ü®Q, p, h‚ü© := ‚ü®Q, p.rew (s^Q.length), by simp[h]‚ü©

instance : has_pow (pnf L) ‚Ñï := ‚ü®Œª p i, p.rew (Œª x, #(x + i))‚ü©

lemma rew_eq : ‚àÄ (p : pnf L) (s : ‚Ñï ‚Üí term L), (p.rew s).to_formula = p.to_formula.rew s
| ‚ü®[], p, h‚ü©     s := by simp[rew]
| ‚ü®ùö∑ :: Q, p, h‚ü© s := by simp[rew, ‚Üêrew_eq ‚ü®Q, p, by simp[h]‚ü© (s^1), rewriting_sf_itr.pow_add,
    show 1 + Q.length = Q.length + 1, from add_comm _ _]
| ‚ü®ùö∫ :: Q, p, h‚ü© s := by simp[rew, ‚Üêrew_eq ‚ü®Q, p, by simp[h]‚ü© (s^1), rewriting_sf_itr.pow_add,
    show 1 + Q.length = Q.length + 1, from add_comm _ _]

lemma pow_eq (p : pnf L) (i : ‚Ñï) : (p^i).to_formula = p.to_formula^i :=
by simp[formula.pow_eq, rew_eq, has_pow.pow]

@[simp] def neg : pnf L ‚Üí pnf L
| ‚ü®[], p, h‚ü© := ‚ü®[], ‚Åªp, by simp[h]‚ü©
| ‚ü®ùö∑ :: Q, p, h‚ü© := ‚àê neg ‚ü®Q, p, by simp[h]‚ü©
| ‚ü®ùö∫ :: Q, p, h‚ü© := ‚àè neg ‚ü®Q, p, by simp[h]‚ü©
using_well_founded {rel_tac := Œª _ _, `[exact ‚ü®_, measure_wf rank‚ü©]}

@[simp] lemma rew_rank : ‚àÄ (p : pnf L) (s), (p.rew s).rank = p.rank
| ‚ü®[], p, h‚ü©     s := by simp[rew]
| ‚ü®ùö∑ :: Q, p, h‚ü© s := by simp[rew]
| ‚ü®ùö∫ :: Q, p, h‚ü© s := by simp[rew]

@[simp] lemma pow_rank (p : pnf L) (i : ‚Ñï) : (p^i).rank = p.rank :=
by simp[has_pow.pow]

@[simp] def imply : pnf L ‚Üí pnf L ‚Üí pnf L
| ‚ü®[], p‚ÇÅ, h‚ÇÅ‚ü©      ‚ü®[], p‚ÇÇ, h‚ÇÇ‚ü©      := ‚ü®[], p‚ÇÅ ‚ü∂ p‚ÇÇ, by simp[h‚ÇÅ, h‚ÇÇ]‚ü©
| ‚ü®[], p‚ÇÅ, h‚ÇÅ‚ü©      ‚ü®ùö∑ :: Q‚ÇÇ, p‚ÇÇ, h‚ÇÇ‚ü© := ‚àè imply (‚ü®[], p‚ÇÅ^1, by simp[h‚ÇÅ]‚ü©) ‚ü®Q‚ÇÇ, p‚ÇÇ, h‚ÇÇ‚ü©
| ‚ü®[], p‚ÇÅ, h‚ÇÅ‚ü©      ‚ü®ùö∫ :: Q‚ÇÇ, p‚ÇÇ, h‚ÇÇ‚ü© := ‚àê imply ‚ü®[], p‚ÇÅ^1, by simp[h‚ÇÅ]‚ü© ‚ü®Q‚ÇÇ, p‚ÇÇ, h‚ÇÇ‚ü©
| ‚ü®ùö∑ :: Q‚ÇÅ, p‚ÇÅ, h‚ÇÅ‚ü© ‚ü®[], p‚ÇÇ, h‚ÇÇ‚ü©      := ‚àê imply ‚ü®Q‚ÇÅ, p‚ÇÅ, by simp[h‚ÇÅ]‚ü© ‚ü®[], p‚ÇÇ^1, by simp[h‚ÇÇ]‚ü©
| ‚ü®ùö∑ :: Q‚ÇÅ, p‚ÇÅ, h‚ÇÅ‚ü© ‚ü®ùö∑ :: Q‚ÇÇ, p‚ÇÇ, h‚ÇÇ‚ü© :=
    ‚àê (‚àè imply (pnf.mk Q‚ÇÅ p‚ÇÅ h‚ÇÅ^1) ((pnf.mk Q‚ÇÇ p‚ÇÇ (by simp[h‚ÇÇ])).rew Œπ-{1}) : pnf L)
| ‚ü®ùö∑ :: Q‚ÇÅ, p‚ÇÅ, h‚ÇÅ‚ü© ‚ü®ùö∫ :: Q‚ÇÇ, p‚ÇÇ, h‚ÇÇ‚ü© :=
    ‚àê (‚àê imply (pnf.mk Q‚ÇÅ p‚ÇÅ h‚ÇÅ^1) ((pnf.mk Q‚ÇÇ p‚ÇÇ (by simp[h‚ÇÇ])).rew Œπ-{1}) : pnf L)
| ‚ü®ùö∫ :: Q‚ÇÅ, p‚ÇÅ, h‚ÇÅ‚ü© ‚ü®[], p‚ÇÇ, h‚ÇÇ‚ü©      := ‚àè imply ‚ü®Q‚ÇÅ, p‚ÇÅ, by simp[h‚ÇÅ]‚ü© ‚ü®[], p‚ÇÇ^1, by simp[h‚ÇÇ]‚ü©
| ‚ü®ùö∫ :: Q‚ÇÅ, p‚ÇÅ, h‚ÇÅ‚ü© ‚ü®ùö∑ :: Q‚ÇÇ, p‚ÇÇ, h‚ÇÇ‚ü© :=
    ‚àè (‚àè imply (pnf.mk Q‚ÇÅ p‚ÇÅ h‚ÇÅ^1) ((pnf.mk Q‚ÇÇ p‚ÇÇ (by simp[h‚ÇÇ])).rew Œπ-{1}) : pnf L)
| ‚ü®ùö∫ :: Q‚ÇÅ, p‚ÇÅ, h‚ÇÅ‚ü© ‚ü®ùö∫ :: Q‚ÇÇ, p‚ÇÇ, h‚ÇÇ‚ü© :=
    ‚àè (‚àê imply (pnf.mk Q‚ÇÅ p‚ÇÅ h‚ÇÅ^1) ((pnf.mk Q‚ÇÇ p‚ÇÇ (by simp[h‚ÇÇ])).rew Œπ-{1}) : pnf L)
using_well_founded {rel_tac := Œª _ _, `[exact ‚ü®_, measure_wf (Œª x, x.fst.rank + x.snd.rank)‚ü©]}

end pnf

namespace formula

@[simp] def to_pnf : formula L ‚Üí pnf L
| (app p v) := ‚ü®[], app p v, by simp‚ü©
| ((t : term L) ‚âÉ u) := ‚ü®[], (t : term L) ‚âÉ u, by simp‚ü©
| (p ‚ü∂ q) := (to_pnf p).imply (to_pnf q)
| (‚Åªp) := (to_pnf p).neg
| (‚àè (p : formula L)) := ‚àè (to_pnf p)

end formula

lemma iff_pnf_imply : ‚àÄ (p q : pnf L) (T : theory L), T ‚ä¢ (p.imply q).to_formula ‚ü∑ p.to_formula ‚ü∂ q.to_formula
| ‚ü®[], p‚ÇÅ, h‚ÇÅ‚ü©      ‚ü®[], p‚ÇÇ, h‚ÇÇ‚ü©      T := by simp
| ‚ü®[], p‚ÇÅ, h‚ÇÅ‚ü©      ‚ü®ùö∑ :: Q‚ÇÇ, p‚ÇÇ, h‚ÇÇ‚ü© T := by { simp, have ih := iff_pnf_imply ‚ü®[], p‚ÇÅ^1, by simp[h‚ÇÅ]‚ü© ‚ü®Q‚ÇÇ, p‚ÇÇ, h‚ÇÇ‚ü©,
    calc     ‚àè ((pnf.mk ([]) (p‚ÇÅ^1) (by simp[h‚ÇÅ])).imply (pnf.mk Q‚ÇÇ p‚ÇÇ h‚ÇÇ)).to_formula
        ‚âà[T] ‚àè ((pnf.mk ([]) (p‚ÇÅ^1) (by simp[h‚ÇÅ])).to_formula ‚ü∂ (pnf.mk Q‚ÇÇ p‚ÇÇ h‚ÇÇ).to_formula)
    : provable.equiv_univ_of_equiv (ih _)
    ... ‚âà[T] p‚ÇÅ ‚ü∂ ‚àè (pnf.mk Q‚ÇÇ p‚ÇÇ h‚ÇÇ).to_formula
    : by { symmetry, refine by simp[classical_logic.equiv] } }
| ‚ü®[], p‚ÇÅ, h‚ÇÅ‚ü©      ‚ü®ùö∫ :: Q‚ÇÇ, p‚ÇÇ, h‚ÇÇ‚ü© T := by { simp, have ih := iff_pnf_imply ‚ü®[], p‚ÇÅ^1, by simp[h‚ÇÅ]‚ü© ‚ü®Q‚ÇÇ, p‚ÇÇ, h‚ÇÇ‚ü©,
    calc     ‚àê ((pnf.mk ([]) (p‚ÇÅ^1) (by simp[h‚ÇÅ])).imply (pnf.mk Q‚ÇÇ p‚ÇÇ h‚ÇÇ)).to_formula
        ‚âà[T] ‚àê ((pnf.mk ([]) (p‚ÇÅ^1) (by simp[h‚ÇÅ])).to_formula ‚ü∂ (pnf.mk Q‚ÇÇ p‚ÇÇ h‚ÇÇ).to_formula)
    : provable.equiv_ex_of_equiv (ih _)
    ... ‚âà[T] p‚ÇÅ ‚ü∂ ‚àê (pnf.mk Q‚ÇÇ p‚ÇÇ h‚ÇÇ).to_formula
    : by { symmetry, simp[classical_logic.equiv] } }
| ‚ü®ùö∑ :: Q‚ÇÅ, p‚ÇÅ, h‚ÇÅ‚ü© ‚ü®[], p‚ÇÇ, h‚ÇÇ‚ü©      T := by { simp, have ih := iff_pnf_imply ‚ü®Q‚ÇÅ, p‚ÇÅ, h‚ÇÅ‚ü© (pnf.mk ([]) p‚ÇÇ h‚ÇÇ^1),
    calc     ‚àê ((pnf.mk Q‚ÇÅ p‚ÇÅ h‚ÇÅ).imply (pnf.mk ([]) p‚ÇÇ h‚ÇÇ^1)).to_formula
        ‚âà[T] ‚àê ((pnf.mk Q‚ÇÅ p‚ÇÅ h‚ÇÅ).to_formula ‚ü∂ (pnf.mk ([]) p‚ÇÇ h‚ÇÇ^1).to_formula)
    : provable.equiv_ex_of_equiv (ih _)
    ... ‚âà[T] ‚àè (pnf.mk Q‚ÇÅ p‚ÇÅ (by simp[h‚ÇÅ])).to_formula ‚ü∂ p‚ÇÇ
    : by { symmetry, simp[classical_logic.equiv, pnf.pow_eq] } }
| ‚ü®ùö∑ :: Q‚ÇÅ, p‚ÇÅ, h‚ÇÅ‚ü© ‚ü®ùö∑ :: Q‚ÇÇ, p‚ÇÇ, h‚ÇÇ‚ü© T := by { simp,
    have ih := iff_pnf_imply (pnf.mk Q‚ÇÅ p‚ÇÅ h‚ÇÅ^1) ((pnf.mk Q‚ÇÇ p‚ÇÇ h‚ÇÇ).rew Œπ-{1}),
    calc     ‚àê ‚àè ((pnf.mk Q‚ÇÅ p‚ÇÅ h‚ÇÅ^1).imply ((pnf.mk Q‚ÇÇ p‚ÇÇ h‚ÇÇ).rew Œπ-{1})).to_formula
        ‚âà[T] ‚àê ‚àè ((pnf.mk Q‚ÇÅ p‚ÇÅ h‚ÇÅ^1).to_formula ‚ü∂ ((pnf.mk Q‚ÇÇ p‚ÇÇ h‚ÇÇ).rew Œπ-{1}).to_formula)
    : provable.equiv_ex_of_equiv (provable.equiv_univ_of_equiv (ih _))
    ... ‚âà[T] ‚àê ((pnf.mk Q‚ÇÅ p‚ÇÅ h‚ÇÅ).to_formula ‚ü∂ (‚àè (pnf.mk Q‚ÇÇ p‚ÇÇ h‚ÇÇ).to_formula)^1)
    : by { show _ ‚âà[T] _, symmetry, simp[pnf.pow_eq, pnf.rew_eq, classical_logic.equiv, formula.fal_pow_discard],
           refine provable.equiv_ex_of_equiv (by simp) }
    ... ‚âà[T] ‚àè (pnf.mk Q‚ÇÅ p‚ÇÅ h‚ÇÅ).to_formula ‚ü∂ ‚àè (pnf.mk Q‚ÇÇ p‚ÇÇ h‚ÇÇ).to_formula
    : by { symmetry, simp [classical_logic.equiv] } }
| ‚ü®ùö∑ :: Q‚ÇÅ, p‚ÇÅ, h‚ÇÅ‚ü© ‚ü®ùö∫ :: Q‚ÇÇ, p‚ÇÇ, h‚ÇÇ‚ü© T := by { simp, 
    have ih := iff_pnf_imply (pnf.mk Q‚ÇÅ p‚ÇÅ h‚ÇÅ^1) ((pnf.mk Q‚ÇÇ p‚ÇÇ h‚ÇÇ).rew Œπ-{1}),
    calc     ‚àê ‚àê ((pnf.mk Q‚ÇÅ p‚ÇÅ h‚ÇÅ^1).imply ((pnf.mk Q‚ÇÇ p‚ÇÇ h‚ÇÇ).rew Œπ-{1})).to_formula
        ‚âà[T] ‚àê ‚àê ((pnf.mk Q‚ÇÅ p‚ÇÅ h‚ÇÅ^1).to_formula ‚ü∂ ((pnf.mk Q‚ÇÇ p‚ÇÇ h‚ÇÇ).rew Œπ-{1}).to_formula)
    : provable.equiv_ex_of_equiv (provable.equiv_ex_of_equiv (ih _))
    ... ‚âà[T] ‚àê ((pnf.mk Q‚ÇÅ p‚ÇÅ h‚ÇÅ).to_formula ‚ü∂ (‚àê (pnf.mk Q‚ÇÇ p‚ÇÇ h‚ÇÇ).to_formula)^1)
    : by { show _ ‚âà[T] _, symmetry, simp[pnf.pow_eq, pnf.rew_eq, classical_logic.equiv, formula.ex_pow_discard],
           refine provable.equiv_ex_of_equiv (by simp) }
    ... ‚âà[T] ‚àè (pnf.mk Q‚ÇÅ p‚ÇÅ h‚ÇÅ).to_formula ‚ü∂ ‚àê (pnf.mk Q‚ÇÇ p‚ÇÇ h‚ÇÇ).to_formula
    : by { symmetry, simp [classical_logic.equiv] } }
| ‚ü®ùö∫ :: Q‚ÇÅ, p‚ÇÅ, h‚ÇÅ‚ü© ‚ü®[], p‚ÇÇ, h‚ÇÇ‚ü©      T := by { simp, have ih := iff_pnf_imply ‚ü®Q‚ÇÅ, p‚ÇÅ, h‚ÇÅ‚ü© (pnf.mk ([]) p‚ÇÇ h‚ÇÇ^1),
    calc     ‚àè ((pnf.mk Q‚ÇÅ p‚ÇÅ h‚ÇÅ).imply (pnf.mk ([]) p‚ÇÇ h‚ÇÇ^1)).to_formula
        ‚âà[T] ‚àè ((pnf.mk Q‚ÇÅ p‚ÇÅ h‚ÇÅ).to_formula ‚ü∂ (pnf.mk ([]) p‚ÇÇ h‚ÇÇ^1).to_formula)
    : provable.equiv_univ_of_equiv (ih _)
    ... ‚âà[T] ‚àê (pnf.mk Q‚ÇÅ p‚ÇÅ (by simp[h‚ÇÅ])).to_formula ‚ü∂ p‚ÇÇ
    : by { symmetry, simp[classical_logic.equiv, pnf.pow_eq] } }
| ‚ü®ùö∫ :: Q‚ÇÅ, p‚ÇÅ, h‚ÇÅ‚ü© ‚ü®ùö∑ :: Q‚ÇÇ, p‚ÇÇ, h‚ÇÇ‚ü© T := by { simp,
    have ih := iff_pnf_imply (pnf.mk Q‚ÇÅ p‚ÇÅ h‚ÇÅ^1) ((pnf.mk Q‚ÇÇ p‚ÇÇ h‚ÇÇ).rew Œπ-{1}),
    calc     ‚àè ‚àè ((pnf.mk Q‚ÇÅ p‚ÇÅ h‚ÇÅ^1).imply ((pnf.mk Q‚ÇÇ p‚ÇÇ h‚ÇÇ).rew Œπ-{1})).to_formula
        ‚âà[T] ‚àè ‚àè ((pnf.mk Q‚ÇÅ p‚ÇÅ h‚ÇÅ^1).to_formula ‚ü∂ ((pnf.mk Q‚ÇÇ p‚ÇÇ h‚ÇÇ).rew Œπ-{1}).to_formula)
    : provable.equiv_univ_of_equiv (provable.equiv_univ_of_equiv (ih _))
    ... ‚âà[T] ‚àè ((pnf.mk Q‚ÇÅ p‚ÇÅ h‚ÇÅ).to_formula ‚ü∂ (‚àè (pnf.mk Q‚ÇÇ p‚ÇÇ h‚ÇÇ).to_formula)^1)
    : by { show _ ‚âà[T] _, symmetry, simp[pnf.pow_eq, pnf.rew_eq, classical_logic.equiv, formula.fal_pow_discard],
           refine provable.equiv_univ_of_equiv (by simp) }
    ... ‚âà[T] ‚àê (pnf.mk Q‚ÇÅ p‚ÇÅ h‚ÇÅ).to_formula ‚ü∂ ‚àè (pnf.mk Q‚ÇÇ p‚ÇÇ h‚ÇÇ).to_formula
    : by { symmetry, simp [classical_logic.equiv] } }
| ‚ü®ùö∫ :: Q‚ÇÅ, p‚ÇÅ, h‚ÇÅ‚ü© ‚ü®ùö∫ :: Q‚ÇÇ, p‚ÇÇ, h‚ÇÇ‚ü© T := by { simp, 
    have ih := iff_pnf_imply (pnf.mk Q‚ÇÅ p‚ÇÅ h‚ÇÅ^1) ((pnf.mk Q‚ÇÇ p‚ÇÇ h‚ÇÇ).rew Œπ-{1}),
    calc     ‚àè ‚àê ((pnf.mk Q‚ÇÅ p‚ÇÅ h‚ÇÅ^1).imply ((pnf.mk Q‚ÇÇ p‚ÇÇ h‚ÇÇ).rew Œπ-{1})).to_formula
        ‚âà[T] ‚àè ‚àê ((pnf.mk Q‚ÇÅ p‚ÇÅ h‚ÇÅ^1).to_formula ‚ü∂ ((pnf.mk Q‚ÇÇ p‚ÇÇ h‚ÇÇ).rew Œπ-{1}).to_formula)
    : provable.equiv_univ_of_equiv (provable.equiv_ex_of_equiv (ih _))
    ... ‚âà[T] ‚àè ((pnf.mk Q‚ÇÅ p‚ÇÅ h‚ÇÅ).to_formula ‚ü∂ (‚àê (pnf.mk Q‚ÇÇ p‚ÇÇ h‚ÇÇ).to_formula)^1)
    : by { show _ ‚âà[T] _, symmetry, simp[pnf.pow_eq, pnf.rew_eq, classical_logic.equiv, formula.ex_pow_discard],
           refine provable.equiv_univ_of_equiv (by simp) }
    ... ‚âà[T] ‚àê (pnf.mk Q‚ÇÅ p‚ÇÅ h‚ÇÅ).to_formula ‚ü∂ ‚àê (pnf.mk Q‚ÇÇ p‚ÇÇ h‚ÇÇ).to_formula
    : by { symmetry, simp [classical_logic.equiv] } }
using_well_founded {rel_tac := Œª _ _, `[exact ‚ü®_, measure_wf (Œª x, x.1.rank + x.2.1.rank)‚ü©]}

lemma iff_pnf_neg : ‚àÄ (p : pnf L) (T : theory L) , T ‚ä¢ p.neg.to_formula ‚ü∑ ‚Åªp.to_formula
| ‚ü®[], p, h‚ü©     T := by simp
| ‚ü®ùö∑ :: Q, p, h‚ü© T := by simp;
    calc ‚àê (pnf.mk Q p (by simp[h])).neg.to_formula ‚âà[T] ‚àê ‚Åª(pnf.mk Q p (by simp[h])).to_formula
    : provable.equiv_ex_of_equiv (iff_pnf_neg ‚ü®Q, p, by simp[h]‚ü© _)
                                                 ... ‚âà[T] ‚Åª‚àè (pnf.mk Q p (by simp[h])).to_formula
    : classical_logic.equiv_neg_of_equiv (provable.equiv_univ_of_equiv (by simp))
| ‚ü®ùö∫ :: Q, p, h‚ü© T := by { simp,
    calc     ‚àè (pnf.mk Q p (by simp[h])).neg.to_formula ‚âà[T] ‚àè ‚Åª(pnf.mk Q p (by simp[h])).to_formula
    : provable.equiv_univ_of_equiv (iff_pnf_neg ‚ü®Q, p, by simp[h]‚ü© _)
                                                    ... ‚âà[T] ‚Åª‚àê (pnf.mk Q p (by simp[h])).to_formula
    : by { simp[has_exists_quantifier.ex, formula.ex, classical_logic.equiv] } }

lemma iff_pnf : ‚àÄ (p : formula L) {T : theory L},  T ‚ä¢ p ‚ü∑ p.to_pnf.to_formula
| (formula.app p v) T := by simp
| (t ‚âÉ‚ÇÅ u)          T := by simp
| (p ‚ü∂ q)          T := by { simp, 
    have : T ‚ä¢ p ‚ü∂ q ‚ü∑ (p.to_pnf.to_formula ‚ü∂ q.to_pnf.to_formula),
      from classical_logic.equiv_imply_of_equiv (iff_pnf p) (iff_pnf q),
    exact classical_logic.equiv_trans this (classical_logic.equiv_symm (iff_pnf_imply p.to_pnf q.to_pnf T)) }
| (‚Åªp)              T := by { simp,
    have : T ‚ä¢ ‚Åªp ‚ü∑ ‚Åªp.to_pnf.to_formula, from classical_logic.equiv_neg_of_equiv (iff_pnf p),
    exact classical_logic.equiv_trans this (classical_logic.equiv_symm (iff_pnf_neg p.to_pnf T)) }
| (‚àè‚ÇÅ p)           T := by { simp, refine provable.equiv_univ_of_equiv (iff_pnf p) }



end fopl