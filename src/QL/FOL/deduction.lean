import QL.FOL.fol provability consistency

universes u v

namespace fol
open_locale logic_symbol
open subterm subformula logic logic.Theory
variables {L : language.{u}} {m : ‚Ñï}

localized "prefix (name := mlift) `ùóü`:max := subformula.mlift" in aclogic
localized "prefix (name := preTheory.mlift) `ùóü'`:max := preTheory.mlift" in aclogic
localized "prefix (name := push) `ùó†`:max := subformula.push" in aclogic
localized "prefix (name := pull) `ùó°`:max := subformula.pull" in aclogic
localized "prefix (name := dummy) `ùóó`:max := subformula.dummy" in aclogic

def eq_axiom4 {m k} (f : L.fn k) : subformula L m 0 :=
‚àÄ'*((‚ãÄ i, #(fin.cast_add k i) =' #(fin.nat_add k i)) ‚ü∂
  (function f (var ‚àò fin.cast_add k) =' function f (var ‚àò fin.nat_add k)) : subformula L m (k + k))

def eq_axiom5 {m k} (r : L.pr k) : subformula L m 0 :=
‚àÄ'*((‚ãÄ i : fin k, #(fin.cast_add k i) =' #(fin.nat_add k i)) ‚ü∂
  (relation r (var ‚àò fin.cast_add k) ‚ü∑ relation r (var ‚àò fin.nat_add k)))

inductive proof : Œ† {m}, preTheory L m ‚Üí subformula L m 0 ‚Üí Type u
| generalize   {m} {T : preTheory L m} : ‚àÄ {p}, proof T.mlift p ‚Üí proof T (‚àÄ'ùó°p)
| mdp          {m} {T : preTheory L m} : ‚àÄ {p q}, proof T (p ‚ü∂ q) ‚Üí proof T p ‚Üí proof T q
| by_axiom     {m} {T : preTheory L m} : ‚àÄ {p}, p ‚àà T ‚Üí proof T p
| verum        {m} {T : preTheory L m} : proof T ‚ä§
| imply‚ÇÅ       {m} {T : preTheory L m} : ‚àÄ {p q}, proof T (p ‚ü∂ q ‚ü∂ p)
| imply‚ÇÇ       {m} {T : preTheory L m} : ‚àÄ {p q r}, proof T ((p ‚ü∂ q ‚ü∂ r) ‚ü∂ (p ‚ü∂ q) ‚ü∂ p ‚ü∂ r)
| contra       {m} {T : preTheory L m} : ‚àÄ {p q}, proof T ((‚àºp ‚ü∂ ‚àºq) ‚ü∂ q ‚ü∂ p)
| specialize   {m} {T : preTheory L m} : ‚àÄ {p} {t}, proof T (‚àÄ'p ‚ü∂ subst t p)
| dummy_univ   {m} {T : preTheory L m} : ‚àÄ {p q}, proof T (‚àÄ'(dummy p ‚ü∂ q) ‚ü∂ p ‚ü∂ ‚àÄ'q)
| non_empty    {m} {T : preTheory L m} : proof T (‚àÉ'‚ä§)
| eq_refl      {m} {T : preTheory L m} : proof T ‚àÄ'(#0 =' #0)
| eq_symm      {m} {T : preTheory L m} : proof T ‚àÄ' ‚àÄ'((#0 =' #1) ‚ü∂ (#1 =' #0))
| eq_trans     {m} {T : preTheory L m} : proof T ‚àÄ' ‚àÄ' ‚àÄ'((#0 =' #1) ‚ü∂ (#1 =' #2) ‚ü∂ (#0 =' #2))
| function_ext {m} {T : preTheory L m} : ‚àÄ {n} {f : L.fn n}, proof T (eq_axiom4 f)
| relation_ext {m} {T : preTheory L m} : ‚àÄ {n} {r : L.pr n}, proof T (eq_axiom5 r)

instance (m : ‚Ñï) : has_Longarrow (formula L m) := ‚ü®proof‚ü©

def provable (m) (T : preTheory L m) (p : formula L m) : Prop := nonempty (T ‚üπ p)

instance (m) : axiomatic_classical_logic' (formula L m) :=
{ turnstile := provable m,
  classical := Œª T,
  { modus_ponens := Œª p q ‚ü®bpq‚ü© ‚ü®bp‚ü©, ‚ü®bpq.mdp bp‚ü©,
    imply‚ÇÅ := Œª p q, ‚ü®proof.imply‚ÇÅ‚ü©, 
    imply‚ÇÇ := Œª p q r, ‚ü®proof.imply‚ÇÇ‚ü©,
    contraposition := Œª p q, ‚ü®proof.contra‚ü©,
    provable_top := ‚ü®proof.verum‚ü©,
    bot_eq := by refl,
    and_def := Œª p q, rfl,
    or_def := Œª p q, rfl },
  by_axiom := Œª T p mem, ‚ü®proof.by_axiom mem‚ü© }

open_locale aclogic

namespace proof
variables {T : preTheory L m}

def weakening' {p} (h : T ‚üπ p) : ‚àÄ {U}, T ‚äÜ U ‚Üí U ‚üπ p :=
begin
  induction h,
  case generalize : m T p hyp_p IH
  { intros U hyp, refine generalize (IH $ set.image_subset _ hyp) },
  case mdp : m T p q hyp_pq hyp_p IH‚ÇÅ IH‚ÇÇ
  { intros U hyp, exact (IH‚ÇÅ hyp).mdp (IH‚ÇÇ hyp) },
  case by_axiom : m T p hyp_p
  { intros U hyp, exact by_axiom (hyp hyp_p) },
  { intros U ss, exact verum },
  { intros U ss, exact imply‚ÇÅ },
  { intros U ss, exact imply‚ÇÇ },
  { intros U ss, exact contra },
  { intros U ss, exact specialize },
  { intros U ss, exact dummy_univ },
  { intros U ss, exact non_empty },
  { intros U ss, exact eq_refl },
  { intros U ss, exact eq_symm },
  { intros U ss, exact eq_trans },
  { intros U ss, exact function_ext },
  { intros U ss, exact relation_ext }
end

end proof

namespace provable
open axiomatic_classical_logic' axiomatic_classical_logic
variables {T U : preTheory L m}

lemma generalize {p} (h : T.mlift ‚ä¢ p) : T ‚ä¢ ‚àÄ'p.pull := by rcases h; exact ‚ü®h.generalize‚ü©

lemma generalize' {T : preTheory L (m + 1)} {p} (h : T ‚ä¢ p) (hT : T = U.mlift) : U ‚ä¢ ‚àÄ'p.pull :=
by rcases hT with rfl; exact generalize h

lemma gen {p : subformula L m 1} (h : T.mlift ‚ä¢ p.push) : T ‚ä¢ ‚àÄ'p :=
by rw[‚Üêsubformula.pull_push p]; exact generalize h

lemma by_axiom {p} (h : p ‚àà T) : T ‚ä¢ p := ‚ü®proof.by_axiom h‚ü©

variables (T)

@[simp] lemma specialize (p) (t) : T ‚ä¢ ‚àÄ'p ‚ü∂ subst t p := ‚ü®proof.specialize‚ü©

variables {T}

lemma forall_subst {p} (h : T ‚ä¢ ‚àÄ'p) (t) : T ‚ä¢ subst t p :=
specialize T p t ‚®Ä h

infix ` ‚äö `:60 := forall_subst

variables (T)

@[simp] lemma dummy_univ (p q) : T ‚ä¢ ‚àÄ'(dummy p ‚ü∂ q) ‚ü∂ p ‚ü∂ ‚àÄ'q := ‚ü®proof.dummy_univ‚ü©

@[simp] lemma non_empty : T ‚ä¢ ‚àÉ'‚ä§ := ‚ü®proof.non_empty‚ü©

@[simp] lemma eq_refl : T ‚ä¢ ‚àÄ'(#0 =' #0) := ‚ü®proof.eq_refl‚ü©

@[simp] lemma eq_symm : T ‚ä¢ ‚àÄ' ‚àÄ'((#0 =' #1) ‚ü∂ (#1 =' #0)) := ‚ü®proof.eq_symm‚ü©

@[simp] lemma eq_trans : T ‚ä¢ ‚àÄ' ‚àÄ' ‚àÄ'((#0 =' #1) ‚ü∂ (#1 =' #2) ‚ü∂ (#0 =' #2)) := ‚ü®proof.eq_trans‚ü©

@[simp] lemma function_ext {n} (f : L.fn n) : T ‚ä¢ eq_axiom4 f := ‚ü®proof.function_ext‚ü©

@[simp] lemma relation_ext {n} (r : L.pr n) : T ‚ä¢ eq_axiom5 r := ‚ü®proof.relation_ext‚ü©

variables {T U}

theorem rec_on {C : Œ† {m} (T : preTheory L m) (p : subformula L m 0), T ‚ä¢ p ‚Üí Prop}
  {m : ‚Ñï} {T : preTheory L m} {p : formula L m} (b : T ‚ä¢ p)
  (generalize : ‚àÄ {m} {T : preTheory L m} {p} (b : T.mlift ‚ä¢ p), C T.mlift p b ‚Üí C T (‚àÄ'p.pull) (generalize b))
  (mdp : ‚àÄ {m} {T : preTheory L m} {p q} (b‚ÇÅ : T ‚ä¢ p ‚ü∂ q) (b‚ÇÇ : T ‚ä¢ p), C T (p ‚ü∂ q) b‚ÇÅ ‚Üí C T p b‚ÇÇ ‚Üí C T q (b‚ÇÅ ‚®Ä b‚ÇÇ))
  (by_axiom : ‚àÄ {m} {T : preTheory L m} {p} (h : p ‚àà T), C T p (by_axiom h))
  (verum : ‚àÄ {m} {T : preTheory L m}, C T ‚ä§ axiomatic_classical_logic'.provable_top)
  (imply‚ÇÅ : ‚àÄ {m} {T : preTheory L m} {p q}, C T (p ‚ü∂ q ‚ü∂ p) (axiomatic_classical_logic'.imply‚ÇÅ p q))
  (imply‚ÇÇ : ‚àÄ {m} {T : preTheory L m} {p q r}, C T ((p ‚ü∂ q ‚ü∂ r) ‚ü∂ (p ‚ü∂ q) ‚ü∂ p ‚ü∂ r) (axiomatic_classical_logic'.imply‚ÇÇ p q r))
  (contra : ‚àÄ {m} {T : preTheory L m} {p q}, C T ((‚àºp ‚ü∂ ‚àºq) ‚ü∂ q ‚ü∂ p) (axiomatic_classical_logic'.contraposition p q)) 
  (specialize : ‚àÄ {m} {T : preTheory L m} {p} {t}, C T (‚àÄ'p ‚ü∂ subst t p) (specialize T p t))
  (dummy_univ : ‚àÄ {m} {T : preTheory L m} {p q}, C T (‚àÄ'(dummy p ‚ü∂ q) ‚ü∂ p ‚ü∂ ‚àÄ'q) (dummy_univ T p q))
  (non_empty : ‚àÄ {m} {T : preTheory L m}, C T (‚àÉ'‚ä§) (non_empty T))
  (eq_refl : ‚àÄ {m} {T : preTheory L m}, C T (‚àÄ'(#0 =' #0)) (eq_refl T))
  (eq_symm : ‚àÄ {m} {T : preTheory L m}, C T (‚àÄ' ‚àÄ'((#0 =' #1) ‚ü∂ (#1 =' #0))) (eq_symm T))
  (eq_trans : ‚àÄ {m} {T : preTheory L m}, C T (‚àÄ' ‚àÄ' ‚àÄ'((#0 =' #1) ‚ü∂ (#1 =' #2) ‚ü∂ (#0 =' #2))) (eq_trans T))
  (function_ext : ‚àÄ {m} {T : preTheory L m} {p} {f : L.fn p}, C T (eq_axiom4 f) (function_ext T f))
  (relation_ext : ‚àÄ {m} {T : preTheory L m} {p} {r : L.pr p}, C T (eq_axiom5 r) (relation_ext T r)) :
  C T p b :=
begin
  rcases b with ‚ü®b‚ü©,
  induction b,
  case generalize : m T p b IH { exact generalize ‚ü®b‚ü© IH },
  case mdp : m T p q b‚ÇÅ b‚ÇÇ IH‚ÇÅ IH‚ÇÇ { exact mdp ‚ü®b‚ÇÅ‚ü© ‚ü®b‚ÇÇ‚ü© IH‚ÇÅ IH‚ÇÇ },
  case by_axiom : m T p hp { exact by_axiom hp },
  case verum : m T { exact verum },
  case imply‚ÇÅ : m T p q { exact imply‚ÇÅ },
  case imply‚ÇÇ : m T p q r { exact imply‚ÇÇ },
  case contra : m T p q { exact contra },
  case specialize : m T p t { exact specialize },
  case dummy_univ : m T p q { exact dummy_univ },
  case non_empty { exact non_empty },
  case eq_refl : { exact eq_refl },
  case eq_symm : { exact eq_symm },
  case eq_trans : { exact eq_trans },
  case function_ext : T p f { exact function_ext },
  case relation_ext : T p f { exact relation_ext }
end

noncomputable def provable.proof {T : preTheory L m} {p : formula L m} (b : T ‚ä¢ p) : T ‚üπ p := nonempty.some b

def weakening_aux {p} (h : T ‚ä¢ p) : ‚àÄ {U}, T ‚äÜ U ‚Üí U ‚ä¢ p :=
begin
  apply rec_on h,
  { intros m T p b IH U hyp, refine generalize (IH $ set.image_subset _ hyp) },
  { intros m T p q hyp_pq hyp_p IH‚ÇÅ IH‚ÇÇ U hyp, exact (IH‚ÇÅ hyp) ‚®Ä (IH‚ÇÇ hyp) },
  { intros m T p hyp_p U hyp, exact by_axiom (hyp hyp_p) },
  { intros, simp },
  { intros, simp },
  { intros, simp },
  { intros, simp },
  { intros, simp },
  { intros, simp },
  { intros, simp },
  { intros, simp },
  { intros, simp },
  { intros, simp },
  { intros, simp },
  { intros, simp }
end

lemma deduction_aux {q} (h : T ‚ä¢ q) : ‚àÄ (U) (p) (hT : T = insert p U), U ‚ä¢ p ‚ü∂ q :=
begin
  apply rec_on h,
  { rintros m T q b IH U p rfl,
    have : U.mlift ‚ä¢ p.mlift ‚ü∂ q, from IH U.mlift p.mlift (by simp[preTheory.mlift_insert]),
    have IH : U ‚ä¢ ‚àÄ'(p.dummy ‚ü∂ q.pull), from generalize this,
    have : U ‚ä¢ ‚àÄ'(p.dummy ‚ü∂ q.pull) ‚ü∂ p ‚ü∂ ‚àÄ'q.pull, by simp,
    show U ‚ä¢ p ‚ü∂ ‚àÄ'q.pull, from this ‚®Ä IH },
  { rintros m T p‚ÇÅ p‚ÇÇ b‚ÇÅ b‚ÇÇ IH‚ÇÅ IH‚ÇÇ U p rfl,
    show U ‚ä¢ p ‚ü∂ p‚ÇÇ, from (IH‚ÇÅ U p rfl) ‚®Ä‚ÇÅ (IH‚ÇÇ U p rfl) },
  { rintros m T p hp U r rfl, rcases hp with (rfl | hp),
    { simp }, { have : U ‚ä¢ p, from by_axiom hp, exact hyp_right this r } },
  { rintros m T U p rfl, simp },
  { rintros m T p q U r rfl, simp },
  { rintros m T p q r U s rfl, simp },
  { rintros m T p q U r rfl, simp },
  { rintros m T p t U q rfl, refine hyp_right (specialize _ p t) _ },
  { rintros m T p q U r rfl, refine hyp_right (dummy_univ _ p q) _ },
  { intros, simp },
  { intros, simp },
  { intros, simp },
  { intros, simp },
  { rintros m T _ f U p rfl, refine hyp_right (function_ext _ f) _ },
  { rintros m T _ f U p rfl, refine hyp_right (relation_ext _ f) _ }
end

instance : axiomatic_classical_logic (formula L m) :=
{ deduction' := Œª T p q h, deduction_aux h T p rfl,
  weakening := Œª T U p ss b, weakening_aux b ss }

lemma empty_axiom_generalize {p : formula L (m + 1)} (hp : ‚¨ù‚ä¢ p) : ‚¨ù‚ä¢ ‚àÄ'p.pull :=
by { have : preTheory.mlift ‚àÖ ‚ä¢ p, by simpa[preTheory.mlift] using hp, exact generalize this }

private lemma mlift_list_conjunction (P‚ÇÄ : list (formula L $ m + 1)) : (‚àÄ p, p ‚àà P‚ÇÄ ‚Üí p ‚àà T.mlift) ‚Üí
  ‚àÉ P : list (formula L m), P.conjunction.mlift = P‚ÇÄ.conjunction ‚àß (‚àÄ p, p ‚àà P ‚Üí p ‚àà T) :=
begin
  induction P‚ÇÄ with p‚ÇÄ P‚ÇÄ IH,
  { intros _, refine ‚ü®[], by simp‚ü© },
  { intros h,
    have : ‚àÉ P : list (formula L m), P.conjunction.mlift = P‚ÇÄ.conjunction ‚àß (‚àÄ p, p ‚àà P ‚Üí p ‚àà T),
    from IH (Œª p hp, h p (by simp[hp])),
    rcases this with ‚ü®P, eq, hP‚ü©,
    have : p‚ÇÄ ‚àà T.mlift, from h p‚ÇÄ (by simp), rcases this with ‚ü®p, hp, rfl‚ü©,
    refine ‚ü®p :: P, by simpa using eq, by { rintros q (rfl | hq), { exact hp }, { exact hP q hq } }‚ü© }
end

theorem finite_character_aux {m} {T : preTheory L m} {p} :
  T ‚ä¢ p ‚Üí ‚àÉ P : list (formula L m), (‚àÄ p, p ‚àà P ‚Üí p ‚àà T) ‚àß ‚¨ù‚ä¢ P.conjunction ‚ü∂ p := Œª h,
begin
  apply rec_on h,
  { rintros m T p b ‚ü®P‚ÇÄ, IH, IHb‚ü©,
    have : ‚àÉ P : list (formula L m), P.conjunction.mlift = P‚ÇÄ.conjunction ‚àß ‚àÄ p, p ‚àà P ‚Üí p ‚àà T,
    from mlift_list_conjunction P‚ÇÄ IH,
    rcases this with ‚ü®P, eqP, hP‚ü©,
    refine ‚ü®P, hP, _‚ü©,
    have : ‚¨ù‚ä¢ ‚àÄ'(P.conjunction.dummy ‚ü∂ p.pull),
    { have := empty_axiom_generalize IHb, rw[‚ÜêeqP] at this; exact this },
    exact dummy_univ _ P.conjunction p.pull ‚®Ä this },
  { rintros m T p q b‚ÇÅ b‚ÇÇ ‚ü®P‚ÇÅ, IH‚ÇÅ, IHb‚ÇÅ‚ü© ‚ü®P‚ÇÇ, IH‚ÇÇ, IHb‚ÇÇ‚ü©,
    refine ‚ü®P‚ÇÅ ++ P‚ÇÇ, _, _‚ü©,
    { simp, rintros p (hp | hp), { exact IH‚ÇÅ p hp }, { exact IH‚ÇÇ p hp } },
    { have    : ‚¨ù‚ä¢ (P‚ÇÅ ++ P‚ÇÇ).conjunction ‚ü∂ P‚ÇÅ.conjunction, from list_conjunction_weakening (by simp),
      have h‚ÇÅ : ‚¨ù‚ä¢ (P‚ÇÅ ++ P‚ÇÇ).conjunction ‚ü∂ p ‚ü∂ q, from imply_trans this IHb‚ÇÅ,
      have    : ‚¨ù‚ä¢ (P‚ÇÅ ++ P‚ÇÇ).conjunction ‚ü∂ P‚ÇÇ.conjunction, from list_conjunction_weakening (by simp),
      have h‚ÇÇ : ‚¨ù‚ä¢ (P‚ÇÅ ++ P‚ÇÇ).conjunction ‚ü∂ p, from imply_trans this IHb‚ÇÇ,
      exact h‚ÇÅ ‚®Ä‚ÇÅ h‚ÇÇ } },
  { rintros m T p hp, refine ‚ü®[p], by simp[hp], _‚ü©, simp, refine deduction.mp (by simp) },
  { rintros m T, refine ‚ü®[], by simp, by simp[empty_axiom]‚ü© },
  { rintros m T p q, refine ‚ü®[], by simp, by simp[empty_axiom]‚ü© },
  { rintros m T p q r, refine ‚ü®[], by simp, by simp[empty_axiom]‚ü© },
  { rintros m T p q, refine ‚ü®[], by simp, by simp[empty_axiom]‚ü© },
  { rintros m T p t, refine ‚ü®[], by simp, by simp[empty_axiom]‚ü© },
  { rintros m T p q, refine ‚ü®[], by simp, by simp[empty_axiom]‚ü© },
  { rintros m T, refine ‚ü®[], by simp, by simp[empty_axiom]‚ü© },
  { rintros m T, refine ‚ü®[], by simp, by simp[empty_axiom]‚ü© },
  { rintros m T, refine ‚ü®[], by simp, by simp[empty_axiom]‚ü© },
  { rintros m T, refine ‚ü®[], by simp, by simp[empty_axiom]‚ü© },
  { rintros m T p f, refine ‚ü®[], by simp, by simp[empty_axiom]‚ü© },
  { rintros m T p r, refine ‚ü®[], by simp, by simp[empty_axiom]‚ü© },
end

instance : has_finite_character (formula L m) :=
finite_character_of_finite_provable (formula L m) (Œª T p, finite_character_aux)

lemma exists_of_subst (p : subformula L m 1) (t) : T ‚ä¢ subst t p ‚ü∂ ‚àÉ'p :=
contrapose.mp (imply_of_equiv
  (show T ‚ä¢ p.neg.fal ‚ü∂ ‚àºsubst t p, by simpa using specialize T (‚àºp) t)
  (iff_dn_refl_right $ ‚àÄ'‚àºp) (equiv_refl _))

lemma specialize' {T} (p : subformula L m 1) : T ‚ä¢ ‚àÄ' ùóü p ‚ü∂ ùó† p :=
by { have : T ‚ä¢ ‚àÄ' ùóü p ‚ü∂ subst &0 p.mlift, from specialize T p.mlift &0, simpa using this }

lemma use {p : subformula L m 1} (t) (h : T ‚ä¢ subst t p) : T ‚ä¢ ‚àÉ'p :=
exists_of_subst p t ‚®Ä h

@[simp] lemma forall_top : T ‚ä¢ ‚àÄ'‚ä§ :=
gen (by simp)

lemma forallK (p q) : T ‚ä¢ ‚àÄ'(p ‚ü∂ q) ‚ü∂ ‚àÄ'p ‚ü∂ ‚àÄ'q :=
begin
  have lmm‚ÇÅ : T ‚ä¢ ‚àÄ'(p ‚ü∂ q) ‚ü∂ ‚àÄ'(ùóó (‚àÄ' p) ‚ü∂ q),
  { have : ùóü'T +{ ‚àÄ'(ùóü p ‚ü∂ ùóü q) } ‚ä¢ ùó† p ‚ü∂ ùó† q, from deduction.mpr (by simpa using specialize' (p ‚ü∂ q)),
    have : ùóü'T +{ ‚àÄ'(ùóü p ‚ü∂ ùóü q) } ‚ä¢ ‚àÄ'ùóü p ‚ü∂ ùó† q, from imply_trans (specialize' _) this, 
    refine deduction.mp (gen _), simp[preTheory.mlift_insert], exact this },
  have lmm‚ÇÇ : T ‚ä¢ ‚àÄ'(ùóó (‚àÄ'p) ‚ü∂ q) ‚ü∂ ‚àÄ'p ‚ü∂ ‚àÄ'q, from dummy_univ T (‚àÄ'p) q,
  exact imply_trans lmm‚ÇÅ lmm‚ÇÇ
end

lemma forall_of_equiv {p‚ÇÅ p‚ÇÇ} (h : T ‚ä¢ ‚àÄ' p‚ÇÅ) (hp : ùóü'T ‚ä¢ ùó† p‚ÇÅ ‚ü∑ ùó† p‚ÇÇ) : T ‚ä¢ ‚àÄ' p‚ÇÇ :=
by { have : T ‚ä¢ ‚àÄ'(p‚ÇÅ ‚ü∂ p‚ÇÇ), by simpa using generalize (iff_equiv.mp hp).1,
     exact (forallK _ _) ‚®Ä this ‚®Ä h }

lemma equiv_forall_of_equiv {p‚ÇÅ p‚ÇÇ} (hp : ùóü'T ‚ä¢ ùó† p‚ÇÅ ‚ü∑ ùó† p‚ÇÇ) : T ‚ä¢ ‚àÄ'p‚ÇÅ ‚ü∑ ‚àÄ'p‚ÇÇ :=
by { simp[iff_equiv], split,
  { have : T ‚ä¢ ‚àÄ'(p‚ÇÅ ‚ü∂ p‚ÇÇ), by simpa using generalize (iff_equiv.mp hp).1,
    exact forallK _ _ ‚®Ä this },
  { have : T ‚ä¢ ‚àÄ'(p‚ÇÇ ‚ü∂ p‚ÇÅ), by simpa using generalize (iff_equiv.mp hp).2,
    exact forallK _ _ ‚®Ä this } }

lemma equiv_forall_of_equiv' {p‚ÇÅ p‚ÇÇ} (hp : ùóü'T ‚ä¢ p‚ÇÅ ‚ü∑ p‚ÇÇ) : T ‚ä¢ ‚àÄ' ùó° p‚ÇÅ ‚ü∑ ‚àÄ' ùó° p‚ÇÇ :=
@equiv_forall_of_equiv _ _ T (ùó° p‚ÇÅ) (ùó° p‚ÇÇ) (by simpa using hp)

lemma equiv_exists_of_equiv {p‚ÇÅ p‚ÇÇ} (hp : ùóü'T ‚ä¢ ùó† p‚ÇÅ ‚ü∑ ùó† p‚ÇÇ) : T ‚ä¢ ‚àÉ'p‚ÇÅ ‚ü∑ ‚àÉ'p‚ÇÇ :=
by simp[ex_def]; refine equiv_neg_of_equiv (equiv_forall_of_equiv (by simpa using equiv_neg_of_equiv hp))

lemma equiv_exists_of_equiv' {p‚ÇÅ p‚ÇÇ} (hp : ùóü'T ‚ä¢ p‚ÇÅ ‚ü∑ p‚ÇÇ) : T ‚ä¢ ‚àÉ' ùó° p‚ÇÅ ‚ü∑ ‚àÉ' ùó° p‚ÇÇ :=
@equiv_exists_of_equiv _ _ T (ùó° p‚ÇÅ) (ùó° p‚ÇÇ) (by simpa using hp)

lemma univ_imply_dummy (p : subformula L m 1) (q : subformula L m 0) :
  T ‚ä¢ ‚àÄ'(p ‚ü∂ ùóó q) ‚ü∂ ‚àÉ'p ‚ü∂ q :=
begin
  have : T ‚ä¢ ‚àÄ'(‚àºùóó q ‚ü∂ ‚àºp) ‚ü∂ ‚àºq ‚ü∂ ‚àÄ'‚àºp, by simpa using dummy_univ T (‚àºq) (‚àºp),
  refine imply_of_equiv this (equiv_forall_of_equiv (by simp)) (by simp[ex_def])
end

lemma exists_intro (p : subformula L m 1) (q : subformula L m 0)
  (h : ùóü'T ‚ä¢ ùó† p ‚ü∂ ùóü q) : T ‚ä¢ ‚àÉ'p ‚ü∂ q :=
by { have : T ‚ä¢ ‚àÄ'(p ‚ü∂ ùóó q), by simpa using generalize h,
     exact univ_imply_dummy p q ‚®Ä this }

@[simp] lemma forall_bot : T ‚ä¢ ‚àÄ'‚ä• ‚ü∑ ‚ä• :=
by { simp[iff_equiv],
     have : T ‚ä¢ ‚àº‚àÄ'‚àº‚ä§, by simp[‚Üêex_def],
     refine of_equiv (neg_of_equiv this (equiv_forall_of_equiv (by simp)))
     (neg_iff (‚àÄ'‚ä•)) }

@[simp] lemma forall_dummy (p : formula L m) : T ‚ä¢ ‚àÄ'ùóó p ‚ü∑ p :=
begin
  simp[iff_equiv], split,
  { have : T ‚ä¢ ‚àÄ'(‚ä§ ‚ü∂ ùóó p) ‚ü∂ ‚àÉ'‚ä§ ‚ü∂ p, from univ_imply_dummy ‚ä§ p,
    refine imply_of_equiv this (equiv_forall_of_equiv $ by simp) (by simp) },
  { refine deduction.mp (gen $ by simp) }
end

section prenex_normal_form

lemma neg_forall_pnf (p) : T ‚ä¢ ‚àº‚àÄ'p ‚ü∑ ‚àÉ'‚àºp :=
equiv_neg_of_equiv (equiv_forall_of_equiv (by simp[neg_eq]))

lemma neg_univ_closure_pnf {n} (p : subformula L m n) : T ‚ä¢ ‚àº‚àÄ'*p ‚ü∑ ‚àÉ'*‚àºp :=
begin
  induction n with n IH generalizing m, { simp },
  { simp[forall_comm, subformula.exists_comm],
    have lmm‚ÇÅ : T ‚ä¢ ‚àº‚àÄ'ùó° (‚àÄ'* ùó† p) ‚ü∑ ‚àÉ'‚àºùó° (‚àÄ'* ùó† p), from neg_forall_pnf _,
    have : ùóü'T ‚ä¢ ‚àº‚àÄ'* (ùó† p) ‚ü∑ ‚àÉ'* (‚àºùó† p), from IH (ùó† p),
    have lmm‚ÇÇ : T ‚ä¢ ‚àÉ'‚àºùó° (‚àÄ'* ùó† p) ‚ü∑ ‚àÉ'ùó° (‚àÉ'* ‚àºùó† p), by simpa using equiv_exists_of_equiv' this,
    exact equiv_trans lmm‚ÇÅ lmm‚ÇÇ }
end

lemma neg_exists_pnf (p) : T ‚ä¢ ‚àº‚àÉ'p ‚ü∑ ‚àÄ'‚àºp := by simp[ex_def]

lemma neg_exists_closure_pnf {n} (p : subformula L m n) : T ‚ä¢ ‚àº‚àÉ'*p ‚ü∑ ‚àÄ'*‚àºp :=
begin
  induction n with n IH generalizing m, { simp },
  { simp[forall_comm, subformula.exists_comm],
    have lmm‚ÇÅ : T ‚ä¢ ‚àº‚àÉ'ùó° (‚àÉ'* ùó† p) ‚ü∑ ‚àÄ'‚àºùó° (‚àÉ'* ùó† p), from neg_exists_pnf _,
    have : ùóü'T ‚ä¢ ‚àº‚àÉ'* (ùó† p) ‚ü∑ ‚àÄ'* (‚àºùó† p), from IH (ùó† p),
    have lmm‚ÇÇ : T ‚ä¢ ‚àÄ'‚àºùó° (‚àÉ'* ùó† p) ‚ü∑ ‚àÄ'ùó° (‚àÄ'* ‚àºùó† p), by simpa using equiv_forall_of_equiv' this,
    exact equiv_trans lmm‚ÇÅ lmm‚ÇÇ }
end

@[simp] lemma or_forall_pnf (p q) : T ‚ä¢ (‚àÄ'p) ‚äî q ‚ü∑ ‚àÄ'(p ‚äî ùóó q) :=
begin
  have lmm‚ÇÅ : T ‚ä¢ (‚àÄ'p) ‚äî q ‚ü∂ ‚àÄ'(p ‚äî ùóó q),
  { have : ùóü'T ‚ä¢ (‚àÄ'ùóü p) ‚äî ùóü q ‚ü∂ ùó† p ‚äî ùóü q,
    { have : ùóü'T ‚ä¢ ‚àÄ'ùóü p ‚ü∂ ùó† p, from specialize' p,
      exact or_imply (‚àÄ'ùóü p) (ùóü q) (ùó† p ‚äî ùóü q) ‚®Ä (imply_trans this (by simp)) ‚®Ä (by simp) },
    have : ùóü'(T +{ (‚àÄ'p) ‚äî q }) ‚ä¢ ùó† p ‚äî ùóü q, simpa using deduction.mpr this,
    have : T +{ (‚àÄ'p) ‚äî q } ‚ä¢ ‚àÄ'(p ‚äî ùóó q), by simpa using generalize this,
    exact deduction.mp this },
  have lmm‚ÇÇ : T ‚ä¢ ‚àÄ'(p ‚äî ùóó q) ‚ü∂ (‚àÄ'p) ‚äî q,
  { simp[has_sup.sup, subformula.or, imply_eq, neg_eq],
    have : T ‚ä¢ ‚àÄ'(‚àºp ‚ü∂ ùóó q) ‚ü∂ ‚àÉ'‚àºp ‚ü∂ q, from univ_imply_dummy (‚àºp) q,
    refine imply_of_equiv this (by simp) (equiv_imply_of_equiv (equiv_symm (neg_forall_pnf p)) (by simp)) },
  refine iff_equiv.mpr ‚ü®lmm‚ÇÅ, lmm‚ÇÇ‚ü©
end

@[simp] lemma and_exists_pnf (p q) : T ‚ä¢ (‚àÉ'p) ‚äì q ‚ü∑ ‚àÉ'(p ‚äì ùóó q) :=
begin
  have : T ‚ä¢ (‚àÄ'‚àºp) ‚äî ‚àºq ‚ü∑ ‚àÄ'‚àºp ‚äî ùóó (‚àºq), from or_forall_pnf (‚àºp) (‚àºq),
  refine equiv_of_equiv (equiv_neg_of_equiv this) _ _,
  { show T ‚ä¢ ‚àº((‚àÄ'‚àºp) ‚äî ‚àºq) ‚ü∑ (‚àÉ'p) ‚äì q,
    refine equiv_of_equiv (neg_or_equiv_and_neg (‚àÄ'‚àºp) (‚àºq))
      (equiv_refl _) (equiv_and_of_equiv (equiv_refl _) (iff_dn_refl_left q)) },
  { show T ‚ä¢ ‚àº‚àÄ'(‚àºp ‚äî ùóó (‚àºq)) ‚ü∑ ‚àÉ'(p ‚äì ùóó q),
    refine equiv_neg_of_equiv (equiv_forall_of_equiv $ equiv_symm (by simp[neg_eq])) }
end

@[simp] lemma and_forall_pnf (p q) : T ‚ä¢ (‚àÄ'p) ‚äì q ‚ü∑ ‚àÄ'(p ‚äì ùóó q) :=
begin
  have lmm‚ÇÅ : T ‚ä¢ (‚àÄ'p) ‚äì q ‚ü∂ ‚àÄ'(p ‚äì ùóó q),
  { have : ùóü'T ‚ä¢ (‚àÄ'ùóü p) ‚äì ùóü q ‚ü∂ ùó† p ‚äì ùóü q,
    { have : ùóü'T ‚ä¢ ‚àÄ'ùóü p ‚ü∂ ùó† p, from specialize' p,
      exact imply_and ((‚àÄ'ùóü p) ‚äì ùóü q) (ùó† p) (ùóü q) ‚®Ä (imply_trans (by simp) this) ‚®Ä (by simp) },
    have : ùóü'(T +{ (‚àÄ'p) ‚äì q }) ‚ä¢ ùó† p ‚äì ùóü q, simpa using deduction.mpr this,
    have : T +{ (‚àÄ'p) ‚äì q } ‚ä¢ ‚àÄ'(p ‚äì ùóó q), by simpa using generalize this,
    exact deduction.mp this },
  have lmm‚ÇÇ : T ‚ä¢ ‚àÄ'(p ‚äì ùóó q) ‚ü∂ (‚àÄ'p) ‚äì q,
  { have lmm‚ÇÉ : T ‚ä¢ ‚àÄ'(p ‚äì ùóó q) ‚ü∂ ‚àÄ'p, from forallK (p ‚äì ùóó q) p ‚®Ä (gen $ by simp),
    have lmm‚ÇÑ : T ‚ä¢ ‚àÄ'(p ‚äì ùóó q) ‚ü∂ q,
    { have : T ‚ä¢ ‚àÄ'(p ‚äì ùóó q) ‚ü∂ ‚àÄ'ùóó q, from forallK (p ‚äì ùóó q) (ùóó q) ‚®Ä (gen $ by simp),
      refine imply_trans this (equiv_mp (forall_dummy _)) },
    refine imply_and (‚àÄ'(p ‚äì ùóó q)) (‚àÄ'p) q ‚®Ä lmm‚ÇÉ ‚®Ä lmm‚ÇÑ },
  refine iff_equiv.mpr ‚ü®lmm‚ÇÅ, lmm‚ÇÇ‚ü©
end

@[simp] lemma or_exists_pnf (p q) : T ‚ä¢ (‚àÉ'p) ‚äî q ‚ü∑ ‚àÉ'(p ‚äî ùóó q) :=
begin
  have : T ‚ä¢ (‚àÄ'‚àºp) ‚äì ‚àºq ‚ü∑ ‚àÄ'‚àºp ‚äì ùóó (‚àºq), from and_forall_pnf (‚àºp) (‚àºq),
  have := equiv_neg_of_equiv this,
  refine equiv_of_equiv this _ _,
  { show T ‚ä¢ ‚àº((‚àÄ'‚àºp) ‚äì ‚àºq) ‚ü∑ (‚àÉ'p) ‚äî q,
    refine equiv_of_equiv (neg_and_equiv_or_neg (‚àÄ'‚àºp) (‚àºq))
      (equiv_refl _) (equiv_or_of_equiv (equiv_refl _) (iff_dn_refl_left q)) },
  { show T ‚ä¢ ‚àº‚àÄ'(‚àºp ‚äì ùóó (‚àºq)) ‚ü∑ ‚àÉ'(p ‚äî ùóó q),
    refine equiv_neg_of_equiv (equiv_forall_of_equiv $ equiv_symm (by simp[neg_eq])) }
end

lemma imply_forall_pnf (p q) : T ‚ä¢ (p ‚ü∂ ‚àÄ'q) ‚ü∑ ‚àÄ'(ùóó p ‚ü∂ q) :=
by { have : T ‚ä¢ ((‚àÄ'q) ‚äî ‚àºp) ‚ü∑ ‚àÄ'(q ‚äî ‚àºùóó p), by simpa using or_forall_pnf q ‚àºp,
     exact equiv_of_equiv this (equiv_symm (by simp))
       (equiv_forall_of_equiv (equiv_symm (by simp))) }

lemma imply_exists_pnf (p q) : T ‚ä¢ (p ‚ü∂ ‚àÉ'q) ‚ü∑ ‚àÉ'(ùóó p ‚ü∂ q) :=
by{ have : T ‚ä¢ ((‚àÉ'q) ‚äî ‚àºp) ‚ü∑ ‚àÉ'(q ‚äî ‚àºùóó p), by simpa using or_exists_pnf q ‚àºp,
    refine equiv_of_equiv this (equiv_symm impl_iff_or')
      (equiv_exists_of_equiv $ equiv_symm $ by simp)}

lemma exists_imply_pnf (p q) : T ‚ä¢ (‚àÉ'p ‚ü∂ q) ‚ü∑ ‚àÄ'(p ‚ü∂ ùóó q) :=
by{ have : T ‚ä¢ ((‚àÄ'‚àºp) ‚äî q) ‚ü∑ ‚àÄ'(‚àºp ‚äî ùóó q), by simp,
    refine equiv_of_equiv this _ _,
    { have : T ‚ä¢ (‚àº‚àº‚àÄ'‚àºp) ‚äî q ‚ü∑ ‚àÉ'p ‚ü∂ q, from equiv_symm (by simp[ex_def]),
      refine equiv_trans (equiv_or_of_equiv _ _) this; simp },
    { refine equiv_forall_of_equiv (equiv_symm $ by simp) } }

lemma forall_imply_pnf (p q) : T ‚ä¢ (‚àÄ'p ‚ü∂ q) ‚ü∑ ‚àÉ'(p ‚ü∂ ùóó q) :=
by{ have : T ‚ä¢ ((‚àÉ'‚àºp) ‚äî q) ‚ü∑ ‚àÉ'(‚àºp ‚äî ùóó q), by simp,
    refine equiv_of_equiv this _ _,
    { have : T ‚ä¢ (‚àÉ'‚àºp) ‚äî q ‚ü∑ ‚àÄ'‚àº‚àºp ‚ü∂ q, from equiv_symm (by simp[ex_def]),
      refine equiv_trans this (equiv_imply_of_equiv (equiv_forall_of_equiv _) _); simp },
    { refine equiv_exists_of_equiv (equiv_symm $ by simp) } }

lemma forall_imply_forall_pnf (p q) : T ‚ä¢ (‚àÄ'p ‚ü∂ ‚àÄ'q) ‚ü∑ ‚àÉ' ‚àÄ'(ùó° ùóó ùó† p ‚ü∂ ùóó q) :=
begin
  have : ùóü'T ‚ä¢ (ùó† p ‚ü∂ ‚àÄ'ùóü q) ‚ü∑ ‚àÄ'(ùóó ùó† p ‚ü∂ ùóü q), from imply_forall_pnf (ùó† p) (ùóü q),
  have lmm‚ÇÅ : T ‚ä¢ ‚àÉ'(p ‚ü∂ ‚àÄ' ùóó q) ‚ü∑ ‚àÉ' ‚àÄ'(ùó° ùóó ùó† p ‚ü∂ ùóó q),
    from equiv_exists_of_equiv (by simpa using this),
  have lmm‚ÇÇ : T ‚ä¢ (‚àÄ'p ‚ü∂ ‚àÄ'q) ‚ü∑ ‚àÉ'(p ‚ü∂ ‚àÄ' ùóó q), by simpa using forall_imply_pnf p (‚àÄ'q),
  exact equiv_trans lmm‚ÇÇ lmm‚ÇÅ
end

lemma forall_imply_exists_pnf (p q) : T ‚ä¢ (‚àÄ'p ‚ü∂ ‚àÉ'q) ‚ü∑ ‚àÉ' ‚àÉ'(ùó° ùóó ùó† p ‚ü∂ ùóó q) :=
begin
  have : ùóü'T ‚ä¢ (ùó† p ‚ü∂ ‚àÉ'ùóü q) ‚ü∑ ‚àÉ'(ùóó ùó† p ‚ü∂ ùóü q), from imply_exists_pnf (ùó† p) (ùóü q),
  have lmm‚ÇÅ : T ‚ä¢ ‚àÉ'(p ‚ü∂ ‚àÉ' ùóó q) ‚ü∑ ‚àÉ' ‚àÉ'(ùó° ùóó ùó† p ‚ü∂ ùóó q),
    from equiv_exists_of_equiv (by simpa using this),
  have lmm‚ÇÇ : T ‚ä¢ (‚àÄ'p ‚ü∂ ‚àÉ'q) ‚ü∑ ‚àÉ'(p ‚ü∂ ‚àÉ' ùóó q), by simpa using forall_imply_pnf p (‚àÉ'q),
  exact equiv_trans lmm‚ÇÇ lmm‚ÇÅ
end

lemma exists_imply_forall_pnf (p q) : T ‚ä¢ (‚àÉ'p ‚ü∂ ‚àÄ'q) ‚ü∑ ‚àÄ' ‚àÄ'(ùó° ùóó ùó† p ‚ü∂ ùóó q) :=
begin
  have : ùóü'T ‚ä¢ (ùó† p ‚ü∂ ‚àÄ'ùóü q) ‚ü∑ ‚àÄ'(ùóó ùó† p ‚ü∂ ùóü q), from imply_forall_pnf (ùó† p) (ùóü q),
  have lmm‚ÇÅ : T ‚ä¢ ‚àÄ'(p ‚ü∂ ‚àÄ' ùóó q) ‚ü∑ ‚àÄ' ‚àÄ'(ùó° ùóó ùó† p ‚ü∂ ùóó q),
    from equiv_forall_of_equiv (by simpa using this),
  have lmm‚ÇÇ : T ‚ä¢ (‚àÉ'p ‚ü∂ ‚àÄ'q) ‚ü∑ ‚àÄ'(p ‚ü∂ ‚àÄ' ùóó q), by simpa using exists_imply_pnf p (‚àÄ'q),
  exact equiv_trans lmm‚ÇÇ lmm‚ÇÅ
end

lemma exists_imply_exists_pnf (p q) : T ‚ä¢ (‚àÉ'p ‚ü∂ ‚àÉ'q) ‚ü∑ ‚àÄ' ‚àÉ'(ùó° ùóó ùó† p ‚ü∂ ùóó q) :=
begin
  have : ùóü'T ‚ä¢ (ùó† p ‚ü∂ ‚àÉ'ùóü q) ‚ü∑ ‚àÉ'(ùóó ùó† p ‚ü∂ ùóü q), from imply_exists_pnf (ùó† p) (ùóü q),
  have lmm‚ÇÅ : T ‚ä¢ ‚àÄ'(p ‚ü∂ ‚àÉ' ùóó q) ‚ü∑ ‚àÄ' ‚àÉ'(ùó° ùóó ùó† p ‚ü∂ ùóó q),
    from equiv_forall_of_equiv (by simpa using this),
  have lmm‚ÇÇ : T ‚ä¢ (‚àÉ'p ‚ü∂ ‚àÉ'q) ‚ü∑ ‚àÄ'(p ‚ü∂ ‚àÉ' ùóó q), by simpa using exists_imply_pnf p (‚àÉ'q),
  exact equiv_trans lmm‚ÇÇ lmm‚ÇÅ
end

end prenex_normal_form

section equal
variables {m} {n : ‚Ñï}

lemma specialize_foralls (p : subformula L m n) (w : fin n ‚Üí subterm L m 0) : T ‚ä¢ ‚àÄ'*p ‚ü∂ substs w p :=
begin
  induction n with n IH generalizing m,
  { simp },
  { have : ùóü'T ‚ä¢ ‚àÄ'* ùó† p ‚ü∂ substs (mlift ‚àò w ‚àò fin.cast_succ) (ùó† p),
    from IH (ùó† p) (subterm.mlift ‚àò w ‚àò fin.cast_succ),
    have : T ‚ä¢ ‚àÄ'(ùó° (‚àÄ'*ùó† p) ‚ü∂ ùó° (substs (mlift ‚àò w ‚àò fin.cast_succ) (ùó† p))),
    by simpa using generalize this,
    have lmm‚ÇÅ : T ‚ä¢ ‚àÄ'*p ‚ü∂ ‚àÄ'ùó° (substs (mlift ‚àò w ‚àò fin.cast_succ) (ùó† p)),
    by simpa[forall_comm] using forallK _ _ ‚®Ä this,
    have lmm‚ÇÇ : T ‚ä¢ ‚àÄ'ùó° (substs (mlift ‚àò w ‚àò fin.cast_succ) (ùó† p)) ‚ü∂ substs w p,
    from specialize T (ùó° (substs (mlift ‚àò w ‚àò fin.cast_succ) (ùó† p))) (w $ fin.last n),
    exact imply_trans lmm‚ÇÅ lmm‚ÇÇ }
end

lemma exists_dn (p : subformula L m n) : T ‚ä¢ ‚àÉ'*‚àº‚àºp ‚ü∑ ‚àÉ'*p :=
begin
  induction n with n IH generalizing m; simp[subformula.exists_comm],
  refine equiv_exists_of_equiv (by simpa using IH (ùó† p))
end

lemma exists_of_substs (p : subformula L m n) (w : fin n ‚Üí subterm L m 0) : T ‚ä¢ ‚àÄ'*p ‚ü∂ substs w p :=
begin
  induction n with n IH generalizing m,
  { simp },
  { have : ùóü'T ‚ä¢ ‚àÄ'* ùó† p ‚ü∂ substs (mlift ‚àò w ‚àò fin.cast_succ) (ùó† p),
    from IH (ùó† p) (subterm.mlift ‚àò w ‚àò fin.cast_succ),
    have : T ‚ä¢ ‚àÄ'(ùó° (‚àÄ'*ùó† p) ‚ü∂ ùó° (substs (mlift ‚àò w ‚àò fin.cast_succ) (ùó† p))),
    by simpa using generalize this,
    have lmm‚ÇÅ : T ‚ä¢ ‚àÄ'*p ‚ü∂ ‚àÄ'ùó° (substs (mlift ‚àò w ‚àò fin.cast_succ) (ùó† p)),
    by simpa[forall_comm] using forallK _ _ ‚®Ä this,
    have lmm‚ÇÇ : T ‚ä¢ ‚àÄ'ùó° (substs (mlift ‚àò w ‚àò fin.cast_succ) (ùó† p)) ‚ü∂ substs w p,
    from specialize T (ùó° (substs (mlift ‚àò w ‚àò fin.cast_succ) (ùó† p))) (w $ fin.last n),
    exact imply_trans lmm‚ÇÅ lmm‚ÇÇ }
end

lemma foralls_substs {p : subformula L m n} (h : T ‚ä¢ ‚àÄ'*p) (w) : T ‚ä¢ substs w p :=
specialize_foralls p w ‚®Ä h

@[refl, simp] lemma eq_refl' (t : subterm L m 0) : T ‚ä¢ t =' t :=
by simpa using eq_refl T ‚äö t

@[simp] lemma eq_symm' (t u : subterm L m 0) : T ‚ä¢ (t =' u) ‚ü∂ (u =' t) :=
begin
  have : T ‚ä¢ ‚àÄ'(_ ‚ü∂ _), by simpa using eq_symm T ‚äö u,
  have : T ‚ä¢ _ ‚ü∂ _, by simpa using this ‚äö t, simp at this,
  simp only [show (0 : fin (0 + 1 + 1)) = (fin.last 0).cast_succ, by refl,
             show (1 : fin (0 + 1 + 1)) = fin.last 1, by refl,
             subst_var_cast_succ,
             subst_var_last,
             subst_mlift,
             subst_zero,
             subst_lift_lift] at this,
  assumption
end

@[symm] lemma equal_symm {t u : subterm L m 0} : T ‚ä¢ t =' u ‚Üí T ‚ä¢ u =' t :=
Œª h, eq_symm' t u ‚®Ä h

@[simp] lemma eq_trans' (t‚ÇÅ t‚ÇÇ t‚ÇÉ: subterm L m 0) : T ‚ä¢ (t‚ÇÅ =' t‚ÇÇ) ‚ü∂ (t‚ÇÇ =' t‚ÇÉ) ‚ü∂ (t‚ÇÅ =' t‚ÇÉ) :=
begin
  have : T ‚ä¢ ‚àÄ' ‚àÄ'(_ ‚ü∂ _ ‚ü∂ _), by simpa using eq_trans T ‚äö t‚ÇÉ,
  have : T ‚ä¢ ‚àÄ'(_ ‚ü∂ _ ‚ü∂ _), by simpa using this ‚äö t‚ÇÇ,
  have : T ‚ä¢ _ ‚ü∂ _ ‚ü∂ _, by simpa using this ‚äö t‚ÇÅ, simp at this,
  simp only [show (0 : fin (0 + 1 + 1 + 1)) = (fin.last 0).cast_succ.cast_succ, by refl,
             show (2 : fin (0 + 1 + 1 + 1)) = fin.last _, by refl] at this,
  simp only [show (1 : fin (0 + 1 + 1 + 1)) = (fin.last 1).cast_succ, by refl,
             subst_var_cast_succ,
             subst_var_last,
             subst_mlift,
             subst_zero,
             subst_lift_lift] at this,
  exact this
end

@[trans] lemma equal_trans (t‚ÇÅ t‚ÇÇ t‚ÇÉ: subterm L m 0) : T ‚ä¢ t‚ÇÅ =' t‚ÇÇ ‚Üí T ‚ä¢ t‚ÇÇ =' t‚ÇÉ ‚Üí T ‚ä¢ t‚ÇÅ =' t‚ÇÉ :=
Œª h‚ÇÅ h‚ÇÇ, eq_trans' t‚ÇÅ t‚ÇÇ t‚ÇÉ ‚®Ä h‚ÇÅ ‚®Ä h‚ÇÇ

@[simp] lemma function_ext' {k} (f : L.fn k) (v w : fin k ‚Üí subterm L m 0) :
  T ‚ä¢ (‚ãÄ i, v i =' w i) ‚ü∂ (function f v =' function f w) :=
begin
  let x : fin (k + k) ‚Üí subterm L m 0 := @fin.add_cases k k (Œª _, subterm L m 0) v w,
  have : T ‚ä¢ ‚àÄ'*((‚ãÄ i, #(fin.cast_add k i) =' #(fin.nat_add k i)) ‚ü∂
    (function f (var ‚àò fin.cast_add k) =' function f (var ‚àò fin.nat_add k))), from function_ext T f,
  simpa[x, (‚àò)] using foralls_substs this x
end

lemma eq_function_of_equal {k} (f : L.fn k) {v w : fin k ‚Üí subterm L m 0}
  (h : ‚àÄ i, T ‚ä¢ v i =' w i) : T ‚ä¢ function f v =' function f w :=
function_ext' f v w ‚®Ä by simpa using h

@[simp] lemma relation_ext' {k} (r : L.pr k) (v w : fin k ‚Üí subterm L m 0) :
  T ‚ä¢ (‚ãÄ i, v i =' w i) ‚ü∂ (relation r v ‚ü∑ relation r w) :=
begin
  let x : fin (k + k) ‚Üí subterm L m 0 := @fin.add_cases k k (Œª _, subterm L m 0) v w,
  have : T ‚ä¢ ‚àÄ'*((‚ãÄ i, #(fin.cast_add k i) =' #(fin.nat_add k i)) ‚ü∂
    (relation r (var ‚àò fin.cast_add k) ‚ü∑ relation r (var ‚àò fin.nat_add k))), from relation_ext T r,
  simpa[x, (‚àò)] using foralls_substs this x
end

lemma equiv_relation_of_equal {k} (r : L.pr k) {v w : fin k ‚Üí subterm L m 0}
  (h : ‚àÄ i, T ‚ä¢ v i =' w i) : T ‚ä¢ relation r v ‚ü∑ relation r w :=
relation_ext' r v w ‚®Ä by simpa using h

end equal

end provable

end fol