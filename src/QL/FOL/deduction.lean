import QL.FOL.fol provability consistency

universes u v

namespace fol
open_locale logic_symbol
open subterm subformula logic logic.Theory
variables {L : language.{u}} {m : ‚Ñï}

localized "prefix (name := mlift) `ùóü`:max := fol.subformula.mlift" in aclogic
localized "prefix (name := preTheory.mlift) `ùóü'`:max := fol.preTheory.mlift" in aclogic
localized "prefix (name := push) `ùó†`:max := fol.subformula.push" in aclogic
localized "prefix (name := pull) `ùó°`:max := fol.subformula.pull" in aclogic
localized "prefix (name := dummy) `ùóó`:max := fol.subformula.dummy" in aclogic

inductive proof : Œ† {m}, preTheory L m ‚Üí subformula L m 0 ‚Üí Type u
| generalize   {m} {T : preTheory L m} : ‚àÄ {p}, proof T.mlift p ‚Üí proof T (‚àÄ'ùó°p)
| mdp          {m} {T : preTheory L m} : ‚àÄ {p q}, proof T (p ‚ü∂ q) ‚Üí proof T p ‚Üí proof T q
| by_axiom     {m} {T : preTheory L m} : ‚àÄ {p}, p ‚àà T ‚Üí proof T p
| verum        {m} {T : preTheory L m} : proof T ‚ä§
| imply‚ÇÅ       {m} {T : preTheory L m} : ‚àÄ {p q}, proof T (p ‚ü∂ q ‚ü∂ p)
| imply‚ÇÇ       {m} {T : preTheory L m} : ‚àÄ {p q r}, proof T ((p ‚ü∂ q ‚ü∂ r) ‚ü∂ (p ‚ü∂ q) ‚ü∂ p ‚ü∂ r)
| contra       {m} {T : preTheory L m} : ‚àÄ {p q}, proof T ((‚àºp ‚ü∂ ‚àºq) ‚ü∂ q ‚ü∂ p)
| specialize   {m} {T : preTheory L m} : ‚àÄ {p} {t}, proof T (‚àÄ'p ‚ü∂ subst t p)
| dummy_univ   {m} {T : preTheory L m} : ‚àÄ {p q}, proof T (‚àÄ'(dummy p ‚ü∂ q) ‚ü∂ p ‚ü∂ ‚àÄ'q)

instance (m : ‚Ñï) : has_Longarrow (formula L m) := ‚ü®proof‚ü©

def provable (m) (T : preTheory L m) (p : formula L m) : Prop := nonempty (T ‚üπ p)

instance (m) : axiomatic_classical_logic' (formula L m) :=
{ turnstile := provable m,
  classical := Œª T,
  { modus_ponens := Œª p q ‚ü®bpq‚ü© ‚ü®bp‚ü©, ‚ü®bpq.mdp bp‚ü©,
    imply‚ÇÅ := Œª p q, ‚ü®proof.imply‚ÇÅ‚ü©, 
    imply‚ÇÇ := Œª p q r, ‚ü®proof.imply‚ÇÇ‚ü©,
    contraposition := Œª p q, ‚ü®proof.contra‚ü©,
    provable_top := ‚ü®proof.verum‚ü©,
    bot_eq := by refl,
    and_def := Œª p q, rfl,
    or_def := Œª p q, rfl },
  by_axiom := Œª T p mem, ‚ü®proof.by_axiom mem‚ü© }

open_locale aclogic

namespace proof
variables {T : preTheory L m}

def weakening' {p} (h : T ‚üπ p) : ‚àÄ {U}, T ‚äÜ U ‚Üí U ‚üπ p :=
begin
  induction h,
  case generalize : m T p hyp_p IH
  { intros U hyp, refine generalize (IH $ set.image_subset _ hyp) },
  case mdp : m T p q hyp_pq hyp_p IH‚ÇÅ IH‚ÇÇ
  { intros U hyp, exact (IH‚ÇÅ hyp).mdp (IH‚ÇÇ hyp) },
  case by_axiom : m T p hyp_p
  { intros U hyp, exact by_axiom (hyp hyp_p) },
  { intros U ss, exact verum },
  { intros U ss, exact imply‚ÇÅ },
  { intros U ss, exact imply‚ÇÇ },
  { intros U ss, exact contra },
  { intros U ss, exact specialize },
  { intros U ss, exact dummy_univ },
end

end proof

namespace provable
open axiomatic_classical_logic' axiomatic_classical_logic
variables {T U : preTheory L m}

lemma generalize {p} (h : T.mlift ‚ä¢ p) : T ‚ä¢ ‚àÄ'p.pull := by rcases h; exact ‚ü®h.generalize‚ü©

lemma generalize' {T : preTheory L (m + 1)} {p} (h : T ‚ä¢ p) (hT : T = U.mlift) : U ‚ä¢ ‚àÄ'p.pull :=
by rcases hT with rfl; exact generalize h

lemma gen {p : subformula L m 1} (h : T.mlift ‚ä¢ p.push) : T ‚ä¢ ‚àÄ'p :=
by rw[‚Üêsubformula.pull_push p]; exact generalize h

lemma by_axiom {p} (h : p ‚àà T) : T ‚ä¢ p := ‚ü®proof.by_axiom h‚ü©

variables (T)

@[simp] lemma specialize (p) (t) : T ‚ä¢ ‚àÄ'p ‚ü∂ subst t p := ‚ü®proof.specialize‚ü©

variables {T}

lemma forall_subst {p} (h : T ‚ä¢ ‚àÄ'p) (t) : T ‚ä¢ subst t p :=
specialize T p t ‚®Ä h

infix ` ‚äö `:60 := forall_subst

variables (T)

@[simp] lemma dummy_univ (p q) : T ‚ä¢ ‚àÄ'(dummy p ‚ü∂ q) ‚ü∂ p ‚ü∂ ‚àÄ'q := ‚ü®proof.dummy_univ‚ü©

variables {T U}

@[elab_as_eliminator]
theorem rec_on {C : Œ† {m} (T : preTheory L m) (p : subformula L m 0), T ‚ä¢ p ‚Üí Prop}
  {m : ‚Ñï} {T : preTheory L m} {p : formula L m} (b : T ‚ä¢ p)
  (generalize : ‚àÄ {m} {T : preTheory L m} {p} (b : T.mlift ‚ä¢ p), C T.mlift p b ‚Üí C T (‚àÄ'p.pull) (generalize b))
  (mdp : ‚àÄ {m} {T : preTheory L m} {p q} (b‚ÇÅ : T ‚ä¢ p ‚ü∂ q) (b‚ÇÇ : T ‚ä¢ p), C T (p ‚ü∂ q) b‚ÇÅ ‚Üí C T p b‚ÇÇ ‚Üí C T q (b‚ÇÅ ‚®Ä b‚ÇÇ))
  (by_axiom : ‚àÄ {m} {T : preTheory L m} {p} (h : p ‚àà T), C T p (by_axiom h))
  (verum : ‚àÄ {m} {T : preTheory L m}, C T ‚ä§ axiomatic_classical_logic'.provable_top)
  (imply‚ÇÅ : ‚àÄ {m} {T : preTheory L m} {p q}, C T (p ‚ü∂ q ‚ü∂ p) (axiomatic_classical_logic'.imply‚ÇÅ p q))
  (imply‚ÇÇ : ‚àÄ {m} {T : preTheory L m} {p q r}, C T ((p ‚ü∂ q ‚ü∂ r) ‚ü∂ (p ‚ü∂ q) ‚ü∂ p ‚ü∂ r) (axiomatic_classical_logic'.imply‚ÇÇ p q r))
  (contra : ‚àÄ {m} {T : preTheory L m} {p q}, C T ((‚àºp ‚ü∂ ‚àºq) ‚ü∂ q ‚ü∂ p) (axiomatic_classical_logic'.contraposition p q)) 
  (specialize : ‚àÄ {m} {T : preTheory L m} {p} {t}, C T (‚àÄ'p ‚ü∂ subst t p) (specialize T p t))
  (dummy_univ : ‚àÄ {m} {T : preTheory L m} {p q}, C T (‚àÄ'(dummy p ‚ü∂ q) ‚ü∂ p ‚ü∂ ‚àÄ'q) (dummy_univ T p q)) :
  C T p b :=
begin
  rcases b with ‚ü®b‚ü©,
  induction b,
  case generalize : m T p b IH { exact generalize ‚ü®b‚ü© IH },
  case mdp : m T p q b‚ÇÅ b‚ÇÇ IH‚ÇÅ IH‚ÇÇ { exact mdp ‚ü®b‚ÇÅ‚ü© ‚ü®b‚ÇÇ‚ü© IH‚ÇÅ IH‚ÇÇ },
  case by_axiom : m T p hp { exact by_axiom hp },
  case verum : m T { exact verum },
  case imply‚ÇÅ : m T p q { exact imply‚ÇÅ },
  case imply‚ÇÇ : m T p q r { exact imply‚ÇÇ },
  case contra : m T p q { exact contra },
  case specialize : m T p t { exact specialize },
  case dummy_univ : m T p q { exact dummy_univ }
end

noncomputable def provable.proof {T : preTheory L m} {p : formula L m} (b : T ‚ä¢ p) : T ‚üπ p := nonempty.some b

def weakening_aux {p} (h : T ‚ä¢ p) : ‚àÄ {U}, T ‚äÜ U ‚Üí U ‚ä¢ p :=
begin
  apply rec_on h,
  { intros m T p b IH U hyp, refine generalize (IH $ set.image_subset _ hyp) },
  { intros m T p q hyp_pq hyp_p IH‚ÇÅ IH‚ÇÇ U hyp, exact (IH‚ÇÅ hyp) ‚®Ä (IH‚ÇÇ hyp) },
  { intros m T p hyp_p U hyp, exact by_axiom (hyp hyp_p) },
  { intros, simp },
  { intros, simp },
  { intros, simp },
  { intros, simp },
  { intros, simp },
  { intros, simp }
end

lemma deduction_aux {q} (h : T ‚ä¢ q) : ‚àÄ (U) (p) (hT : T = insert p U), U ‚ä¢ p ‚ü∂ q :=
begin
  apply rec_on h,
  { rintros m T q b IH U p rfl,
    have : U.mlift ‚ä¢ p.mlift ‚ü∂ q, from IH U.mlift p.mlift (by simp[preTheory.mlift_insert]),
    have IH : U ‚ä¢ ‚àÄ'(p.dummy ‚ü∂ q.pull), from generalize this,
    have : U ‚ä¢ ‚àÄ'(p.dummy ‚ü∂ q.pull) ‚ü∂ p ‚ü∂ ‚àÄ'q.pull, by simp,
    show U ‚ä¢ p ‚ü∂ ‚àÄ'q.pull, from this ‚®Ä IH },
  { rintros m T p‚ÇÅ p‚ÇÇ b‚ÇÅ b‚ÇÇ IH‚ÇÅ IH‚ÇÇ U p rfl,
    show U ‚ä¢ p ‚ü∂ p‚ÇÇ, from (IH‚ÇÅ U p rfl) ‚®Ä‚ÇÅ (IH‚ÇÇ U p rfl) },
  { rintros m T p hp U r rfl, rcases hp with (rfl | hp),
    { simp }, { have : U ‚ä¢ p, from by_axiom hp, exact hyp_right this r } },
  { rintros m T U p rfl, simp },
  { rintros m T p q U r rfl, simp },
  { rintros m T p q r U s rfl, simp },
  { rintros m T p q U r rfl, simp },
  { rintros m T p t U q rfl, refine hyp_right (specialize _ p t) _ },
  { rintros m T p q U r rfl, refine hyp_right (dummy_univ _ p q) _ }
end

instance : axiomatic_classical_logic (formula L m) :=
{ deduction' := Œª T p q h, deduction_aux h T p rfl,
  weakening := Œª T U p ss b, weakening_aux b ss }

lemma empty_axiom_generalize {p : formula L (m + 1)} (hp : ‚¨ù‚ä¢ p) : ‚¨ù‚ä¢ ‚àÄ'p.pull :=
by { have : preTheory.mlift ‚àÖ ‚ä¢ p, by simpa[preTheory.mlift] using hp, exact generalize this }

private lemma mlift_list_conjunction (P‚ÇÄ : list (formula L $ m + 1)) : (‚àÄ p, p ‚àà P‚ÇÄ ‚Üí p ‚àà T.mlift) ‚Üí
  ‚àÉ P : list (formula L m), P.conjunction.mlift = P‚ÇÄ.conjunction ‚àß (‚àÄ p, p ‚àà P ‚Üí p ‚àà T) :=
begin
  induction P‚ÇÄ with p‚ÇÄ P‚ÇÄ IH,
  { intros _, refine ‚ü®[], by simp‚ü© },
  { intros h,
    have : ‚àÉ P : list (formula L m), P.conjunction.mlift = P‚ÇÄ.conjunction ‚àß (‚àÄ p, p ‚àà P ‚Üí p ‚àà T),
    from IH (Œª p hp, h p (by simp[hp])),
    rcases this with ‚ü®P, eq, hP‚ü©,
    have : p‚ÇÄ ‚àà T.mlift, from h p‚ÇÄ (by simp), rcases this with ‚ü®p, hp, rfl‚ü©,
    refine ‚ü®p :: P, by simpa using eq, by { rintros q (rfl | hq), { exact hp }, { exact hP q hq } }‚ü© }
end

theorem finite_character_aux {m} {T : preTheory L m} {p} :
  T ‚ä¢ p ‚Üí ‚àÉ P : list (formula L m), (‚àÄ p, p ‚àà P ‚Üí p ‚àà T) ‚àß ‚¨ù‚ä¢ P.conjunction ‚ü∂ p := Œª h,
begin
  apply rec_on h,
  { rintros m T p b ‚ü®P‚ÇÄ, IH, IHb‚ü©,
    have : ‚àÉ P : list (formula L m), P.conjunction.mlift = P‚ÇÄ.conjunction ‚àß ‚àÄ p, p ‚àà P ‚Üí p ‚àà T,
    from mlift_list_conjunction P‚ÇÄ IH,
    rcases this with ‚ü®P, eqP, hP‚ü©,
    refine ‚ü®P, hP, _‚ü©,
    have : ‚¨ù‚ä¢ ‚àÄ'(P.conjunction.dummy ‚ü∂ p.pull),
    { have := empty_axiom_generalize IHb, rw[‚ÜêeqP] at this; exact this },
    exact dummy_univ _ P.conjunction p.pull ‚®Ä this },
  { rintros m T p q b‚ÇÅ b‚ÇÇ ‚ü®P‚ÇÅ, IH‚ÇÅ, IHb‚ÇÅ‚ü© ‚ü®P‚ÇÇ, IH‚ÇÇ, IHb‚ÇÇ‚ü©,
    refine ‚ü®P‚ÇÅ ++ P‚ÇÇ, _, _‚ü©,
    { simp, rintros p (hp | hp), { exact IH‚ÇÅ p hp }, { exact IH‚ÇÇ p hp } },
    { have    : ‚¨ù‚ä¢ (P‚ÇÅ ++ P‚ÇÇ).conjunction ‚ü∂ P‚ÇÅ.conjunction, from list_conjunction_weakening (by simp),
      have h‚ÇÅ : ‚¨ù‚ä¢ (P‚ÇÅ ++ P‚ÇÇ).conjunction ‚ü∂ p ‚ü∂ q, from imply_trans this IHb‚ÇÅ,
      have    : ‚¨ù‚ä¢ (P‚ÇÅ ++ P‚ÇÇ).conjunction ‚ü∂ P‚ÇÇ.conjunction, from list_conjunction_weakening (by simp),
      have h‚ÇÇ : ‚¨ù‚ä¢ (P‚ÇÅ ++ P‚ÇÇ).conjunction ‚ü∂ p, from imply_trans this IHb‚ÇÇ,
      exact h‚ÇÅ ‚®Ä‚ÇÅ h‚ÇÇ } },
  { rintros m T p hp, refine ‚ü®[p], by simp[hp], _‚ü©, simp, refine deduction.mp (by simp) },
  { rintros m T, refine ‚ü®[], by simp, by simp[empty_axiom]‚ü© },
  { rintros m T p q, refine ‚ü®[], by simp, by simp[empty_axiom]‚ü© },
  { rintros m T p q r, refine ‚ü®[], by simp, by simp[empty_axiom]‚ü© },
  { rintros m T p q, refine ‚ü®[], by simp, by simp[empty_axiom]‚ü© },
  { rintros m T p t, refine ‚ü®[], by simp, by simp[empty_axiom]‚ü© },
  { rintros m T p q, refine ‚ü®[], by simp, by simp[empty_axiom]‚ü© }
end

instance : has_finite_character (formula L m) :=
finite_character_of_finite_provable (formula L m) (Œª T p, finite_character_aux)

def extend_of (h : ‚àÄ p ‚àà T, U ‚ä¢ p) : extend T U :=
‚ü®begin
  intros p b,
  rcases finite_character_aux b with ‚ü®P, hP, b‚ü©,
  have : U ‚ä¢ P.conjunction, from list_conjunction_provable (Œª p hp, h _ (hP p hp)),
  exact of_empty_axiom _ b ‚®Ä this
end‚ü©

lemma exists_of_subst (p : subformula L m 1) (t) : T ‚ä¢ subst t p ‚ü∂ ‚àÉ'p :=
contrapose.mp (imply_of_equiv
  (show T ‚ä¢ p.neg.fal ‚ü∂ ‚àºsubst t p, by simpa using specialize T (‚àºp) t)
  (iff_dn_refl_right $ ‚àÄ'‚àºp) (equiv_refl _))

lemma specialize' {T} (p : subformula L m 1) : T ‚ä¢ ‚àÄ' ùóü p ‚ü∂ ùó† p :=
by { have : T ‚ä¢ ‚àÄ' ùóü p ‚ü∂ subst &(fin.last _) p.mlift, from specialize T p.mlift &(fin.last _), simpa using this }

lemma use {p : subformula L m 1} (t) (h : T ‚ä¢ subst t p) : T ‚ä¢ ‚àÉ'p :=
exists_of_subst p t ‚®Ä h

@[simp] lemma forall_top : T ‚ä¢ ‚àÄ'‚ä§ :=
gen (by simp)

lemma forallK (p q) : T ‚ä¢ ‚àÄ'(p ‚ü∂ q) ‚ü∂ ‚àÄ'p ‚ü∂ ‚àÄ'q :=
begin
  have lmm‚ÇÅ : T ‚ä¢ ‚àÄ'(p ‚ü∂ q) ‚ü∂ ‚àÄ'(ùóó (‚àÄ' p) ‚ü∂ q),
  { have : ùóü'T +{ ‚àÄ'(ùóü p ‚ü∂ ùóü q) } ‚ä¢ ùó† p ‚ü∂ ùó† q, from deduction.mpr (by simpa using specialize' (p ‚ü∂ q)),
    have : ùóü'T +{ ‚àÄ'(ùóü p ‚ü∂ ùóü q) } ‚ä¢ ‚àÄ'ùóü p ‚ü∂ ùó† q, from imply_trans (specialize' _) this, 
    refine deduction.mp (gen _), simp[preTheory.mlift_insert], exact this },
  have lmm‚ÇÇ : T ‚ä¢ ‚àÄ'(ùóó (‚àÄ'p) ‚ü∂ q) ‚ü∂ ‚àÄ'p ‚ü∂ ‚àÄ'q, from dummy_univ T (‚àÄ'p) q,
  exact imply_trans lmm‚ÇÅ lmm‚ÇÇ
end

lemma forall_of_equiv {p‚ÇÅ p‚ÇÇ} (h : T ‚ä¢ ‚àÄ' p‚ÇÅ) (hp : ùóü'T ‚ä¢ ùó† p‚ÇÅ ‚ü∑ ùó† p‚ÇÇ) : T ‚ä¢ ‚àÄ' p‚ÇÇ :=
by { have : T ‚ä¢ ‚àÄ'(p‚ÇÅ ‚ü∂ p‚ÇÇ), by simpa using generalize (iff_equiv.mp hp).1,
     exact (forallK _ _) ‚®Ä this ‚®Ä h }

lemma equiv_forall_of_equiv {p‚ÇÅ p‚ÇÇ} (hp : ùóü'T ‚ä¢ ùó† p‚ÇÅ ‚ü∑ ùó† p‚ÇÇ) : T ‚ä¢ ‚àÄ'p‚ÇÅ ‚ü∑ ‚àÄ'p‚ÇÇ :=
by { simp[iff_equiv], split,
  { have : T ‚ä¢ ‚àÄ'(p‚ÇÅ ‚ü∂ p‚ÇÇ), by simpa using generalize (iff_equiv.mp hp).1,
    exact forallK _ _ ‚®Ä this },
  { have : T ‚ä¢ ‚àÄ'(p‚ÇÇ ‚ü∂ p‚ÇÅ), by simpa using generalize (iff_equiv.mp hp).2,
    exact forallK _ _ ‚®Ä this } }

lemma equiv_forall_of_equiv' {p‚ÇÅ p‚ÇÇ} (hp : ùóü'T ‚ä¢ p‚ÇÅ ‚ü∑ p‚ÇÇ) : T ‚ä¢ ‚àÄ' ùó° p‚ÇÅ ‚ü∑ ‚àÄ' ùó° p‚ÇÇ :=
@equiv_forall_of_equiv _ _ T (ùó° p‚ÇÅ) (ùó° p‚ÇÇ) (by simpa using hp)

lemma equiv_exists_of_equiv {p‚ÇÅ p‚ÇÇ} (hp : ùóü'T ‚ä¢ ùó† p‚ÇÅ ‚ü∑ ùó† p‚ÇÇ) : T ‚ä¢ ‚àÉ'p‚ÇÅ ‚ü∑ ‚àÉ'p‚ÇÇ :=
by simp[ex_def]; refine equiv_neg_of_equiv (equiv_forall_of_equiv (by simpa using equiv_neg_of_equiv hp))

lemma equiv_exists_of_equiv' {p‚ÇÅ p‚ÇÇ} (hp : ùóü'T ‚ä¢ p‚ÇÅ ‚ü∑ p‚ÇÇ) : T ‚ä¢ ‚àÉ' ùó° p‚ÇÅ ‚ü∑ ‚àÉ' ùó° p‚ÇÇ :=
@equiv_exists_of_equiv _ _ T (ùó° p‚ÇÅ) (ùó° p‚ÇÇ) (by simpa using hp)

lemma univ_imply_dummy (p : subformula L m 1) (q : subformula L m 0) :
  T ‚ä¢ ‚àÄ'(p ‚ü∂ ùóó q) ‚ü∂ ‚àÉ'p ‚ü∂ q :=
begin
  have : T ‚ä¢ ‚àÄ'(‚àºùóó q ‚ü∂ ‚àºp) ‚ü∂ ‚àºq ‚ü∂ ‚àÄ'‚àºp, by simpa using dummy_univ T (‚àºq) (‚àºp),
  refine imply_of_equiv this (equiv_forall_of_equiv (by simp)) (by simp[ex_def])
end

lemma exists_intro (p : subformula L m 1) (q : subformula L m 0)
  (h : ùóü'T ‚ä¢ ùó† p ‚ü∂ ùóü q) : T ‚ä¢ ‚àÉ'p ‚ü∂ q :=
by { have : T ‚ä¢ ‚àÄ'(p ‚ü∂ ùóó q), by simpa using generalize h,
     exact univ_imply_dummy p q ‚®Ä this }

def Nonempty : preTheory L m := { ‚àÉ'‚ä§, }

instance preTheory_Nonempty (T : preTheory L (m + 1)) : Nonempty.extend T :=
extend_of (by simp[Nonempty]; refine use &0 (by simp))

instance preTheory_of_inhabited [inhabited (L.fn 0)] : Nonempty.extend T :=
extend_of (by simp[Nonempty]; refine use default (by simp))

@[simp] lemma non_empty [Nonempty.extend T] : T ‚ä¢ ‚àÉ'‚ä§ :=
logic.Theory.extend.by_axiom Nonempty T (by simp[Nonempty])

@[simp] lemma forall_bot [Nonempty.extend T] : T ‚ä¢ ‚àÄ'‚ä• ‚ü∑ ‚ä• :=
by { simp[iff_equiv],
     have : T ‚ä¢ ‚àº‚àÄ'‚àº‚ä§, by simp[‚Üêex_def],
     refine of_equiv (neg_of_equiv this (equiv_forall_of_equiv (by simp)))
     (neg_iff (‚àÄ'‚ä•)) }

@[simp] lemma forall_dummy [Nonempty.extend T] (p : formula L m) : T ‚ä¢ ‚àÄ'ùóó p ‚ü∑ p :=
begin
  simp[iff_equiv], split,
  { have : T ‚ä¢ ‚àÄ'(‚ä§ ‚ü∂ ùóó p) ‚ü∂ ‚àÉ'‚ä§ ‚ü∂ p, from univ_imply_dummy ‚ä§ p,
    refine imply_of_equiv this (equiv_forall_of_equiv $ by simp) (by simp) },
  { refine deduction.mp (gen $ by simp) }
end

section prenex_normal_form

lemma neg_forall_pnf (p) : T ‚ä¢ ‚àº‚àÄ'p ‚ü∑ ‚àÉ'‚àºp :=
equiv_neg_of_equiv (equiv_forall_of_equiv (by simp[neg_eq]))

lemma neg_univ_closure_pnf {n} (p : subformula L m n) : T ‚ä¢ ‚àº‚àÄ'*p ‚ü∑ ‚àÉ'*‚àºp :=
begin
  induction n with n IH generalizing m, { simp },
  { simp[forall_comm, subformula.exists_comm],
    have lmm‚ÇÅ : T ‚ä¢ ‚àº‚àÄ'ùó° (‚àÄ'* ùó† p) ‚ü∑ ‚àÉ'‚àºùó° (‚àÄ'* ùó† p), from neg_forall_pnf _,
    have : ùóü'T ‚ä¢ ‚àº‚àÄ'* (ùó† p) ‚ü∑ ‚àÉ'* (‚àºùó† p), from IH (ùó† p),
    have lmm‚ÇÇ : T ‚ä¢ ‚àÉ'‚àºùó° (‚àÄ'* ùó† p) ‚ü∑ ‚àÉ'ùó° (‚àÉ'* ‚àºùó† p), by simpa using equiv_exists_of_equiv' this,
    exact equiv_trans lmm‚ÇÅ lmm‚ÇÇ }
end

lemma neg_exists_pnf (p) : T ‚ä¢ ‚àº‚àÉ'p ‚ü∑ ‚àÄ'‚àºp := by simp[ex_def]

lemma neg_exists_closure_pnf {n} (p : subformula L m n) : T ‚ä¢ ‚àº‚àÉ'*p ‚ü∑ ‚àÄ'*‚àºp :=
begin
  induction n with n IH generalizing m, { simp },
  { simp[forall_comm, subformula.exists_comm],
    have lmm‚ÇÅ : T ‚ä¢ ‚àº‚àÉ'ùó° (‚àÉ'* ùó† p) ‚ü∑ ‚àÄ'‚àºùó° (‚àÉ'* ùó† p), from neg_exists_pnf _,
    have : ùóü'T ‚ä¢ ‚àº‚àÉ'* (ùó† p) ‚ü∑ ‚àÄ'* (‚àºùó† p), from IH (ùó† p),
    have lmm‚ÇÇ : T ‚ä¢ ‚àÄ'‚àºùó° (‚àÉ'* ùó† p) ‚ü∑ ‚àÄ'ùó° (‚àÄ'* ‚àºùó† p), by simpa using equiv_forall_of_equiv' this,
    exact equiv_trans lmm‚ÇÅ lmm‚ÇÇ }
end

@[simp] lemma or_forall_pnf (p q) : T ‚ä¢ (‚àÄ'p) ‚äî q ‚ü∑ ‚àÄ'(p ‚äî ùóó q) :=
begin
  have lmm‚ÇÅ : T ‚ä¢ (‚àÄ'p) ‚äî q ‚ü∂ ‚àÄ'(p ‚äî ùóó q),
  { have : ùóü'T ‚ä¢ (‚àÄ'ùóü p) ‚äî ùóü q ‚ü∂ ùó† p ‚äî ùóü q,
    { have : ùóü'T ‚ä¢ ‚àÄ'ùóü p ‚ü∂ ùó† p, from specialize' p,
      exact or_imply (‚àÄ'ùóü p) (ùóü q) (ùó† p ‚äî ùóü q) ‚®Ä (imply_trans this (by simp)) ‚®Ä (by simp) },
    have : ùóü'(T +{ (‚àÄ'p) ‚äî q }) ‚ä¢ ùó† p ‚äî ùóü q, simpa using deduction.mpr this,
    have : T +{ (‚àÄ'p) ‚äî q } ‚ä¢ ‚àÄ'(p ‚äî ùóó q), by simpa using generalize this,
    exact deduction.mp this },
  have lmm‚ÇÇ : T ‚ä¢ ‚àÄ'(p ‚äî ùóó q) ‚ü∂ (‚àÄ'p) ‚äî q,
  { simp[has_sup.sup, subformula.or, imply_eq, neg_eq],
    have : T ‚ä¢ ‚àÄ'(‚àºp ‚ü∂ ùóó q) ‚ü∂ ‚àÉ'‚àºp ‚ü∂ q, from univ_imply_dummy (‚àºp) q,
    refine imply_of_equiv this (by simp) (equiv_imply_of_equiv (equiv_symm (neg_forall_pnf p)) (by simp)) },
  refine iff_equiv.mpr ‚ü®lmm‚ÇÅ, lmm‚ÇÇ‚ü©
end

@[simp] lemma and_exists_pnf (p q) : T ‚ä¢ (‚àÉ'p) ‚äì q ‚ü∑ ‚àÉ'(p ‚äì ùóó q) :=
begin
  have : T ‚ä¢ (‚àÄ'‚àºp) ‚äî ‚àºq ‚ü∑ ‚àÄ'‚àºp ‚äî ùóó (‚àºq), from or_forall_pnf (‚àºp) (‚àºq),
  refine equiv_of_equiv (equiv_neg_of_equiv this) _ _,
  { show T ‚ä¢ ‚àº((‚àÄ'‚àºp) ‚äî ‚àºq) ‚ü∑ (‚àÉ'p) ‚äì q,
    refine equiv_of_equiv (neg_or_equiv_and_neg (‚àÄ'‚àºp) (‚àºq))
      (equiv_refl _) (equiv_and_of_equiv (equiv_refl _) (iff_dn_refl_left q)) },
  { show T ‚ä¢ ‚àº‚àÄ'(‚àºp ‚äî ùóó (‚àºq)) ‚ü∑ ‚àÉ'(p ‚äì ùóó q),
    refine equiv_neg_of_equiv (equiv_forall_of_equiv $ equiv_symm (by simp[neg_eq])) }
end

@[simp] lemma and_forall_pnf [Nonempty.extend T] (p q) : T ‚ä¢ (‚àÄ'p) ‚äì q ‚ü∑ ‚àÄ'(p ‚äì ùóó q) :=
begin
  have lmm‚ÇÅ : T ‚ä¢ (‚àÄ'p) ‚äì q ‚ü∂ ‚àÄ'(p ‚äì ùóó q),
  { have : ùóü'T ‚ä¢ (‚àÄ'ùóü p) ‚äì ùóü q ‚ü∂ ùó† p ‚äì ùóü q,
    { have : ùóü'T ‚ä¢ ‚àÄ'ùóü p ‚ü∂ ùó† p, from specialize' p,
      exact imply_and ((‚àÄ'ùóü p) ‚äì ùóü q) (ùó† p) (ùóü q) ‚®Ä (imply_trans (by simp) this) ‚®Ä (by simp) },
    have : ùóü'(T +{ (‚àÄ'p) ‚äì q }) ‚ä¢ ùó† p ‚äì ùóü q, simpa using deduction.mpr this,
    have : T +{ (‚àÄ'p) ‚äì q } ‚ä¢ ‚àÄ'(p ‚äì ùóó q), by simpa using generalize this,
    exact deduction.mp this },
  have lmm‚ÇÇ : T ‚ä¢ ‚àÄ'(p ‚äì ùóó q) ‚ü∂ (‚àÄ'p) ‚äì q,
  { have lmm‚ÇÉ : T ‚ä¢ ‚àÄ'(p ‚äì ùóó q) ‚ü∂ ‚àÄ'p, from forallK (p ‚äì ùóó q) p ‚®Ä (gen $ by simp),
    have lmm‚ÇÑ : T ‚ä¢ ‚àÄ'(p ‚äì ùóó q) ‚ü∂ q,
    { have : T ‚ä¢ ‚àÄ'(p ‚äì ùóó q) ‚ü∂ ‚àÄ'ùóó q, from forallK (p ‚äì ùóó q) (ùóó q) ‚®Ä (gen $ by simp),
      refine imply_trans this (equiv_mp (forall_dummy _)) },
    refine imply_and (‚àÄ'(p ‚äì ùóó q)) (‚àÄ'p) q ‚®Ä lmm‚ÇÉ ‚®Ä lmm‚ÇÑ },
  refine iff_equiv.mpr ‚ü®lmm‚ÇÅ, lmm‚ÇÇ‚ü©
end

@[simp] lemma or_exists_pnf [Nonempty.extend T] (p q) : T ‚ä¢ (‚àÉ'p) ‚äî q ‚ü∑ ‚àÉ'(p ‚äî ùóó q) :=
begin
  have : T ‚ä¢ (‚àÄ'‚àºp) ‚äì ‚àºq ‚ü∑ ‚àÄ'‚àºp ‚äì ùóó (‚àºq), from and_forall_pnf (‚àºp) (‚àºq),
  have := equiv_neg_of_equiv this,
  refine equiv_of_equiv this _ _,
  { show T ‚ä¢ ‚àº((‚àÄ'‚àºp) ‚äì ‚àºq) ‚ü∑ (‚àÉ'p) ‚äî q,
    refine equiv_of_equiv (neg_and_equiv_or_neg (‚àÄ'‚àºp) (‚àºq))
      (equiv_refl _) (equiv_or_of_equiv (equiv_refl _) (iff_dn_refl_left q)) },
  { show T ‚ä¢ ‚àº‚àÄ'(‚àºp ‚äì ùóó (‚àºq)) ‚ü∑ ‚àÉ'(p ‚äî ùóó q),
    refine equiv_neg_of_equiv (equiv_forall_of_equiv $ equiv_symm (by simp[neg_eq])) }
end

lemma imply_forall_pnf (p q) : T ‚ä¢ (p ‚ü∂ ‚àÄ'q) ‚ü∑ ‚àÄ'(ùóó p ‚ü∂ q) :=
by { have : T ‚ä¢ ((‚àÄ'q) ‚äî ‚àºp) ‚ü∑ ‚àÄ'(q ‚äî ‚àºùóó p), by simpa using or_forall_pnf q ‚àºp,
     exact equiv_of_equiv this (equiv_symm (by simp))
       (equiv_forall_of_equiv (equiv_symm (by simp))) }

lemma imply_exists_pnf [Nonempty.extend T] (p q) : T ‚ä¢ (p ‚ü∂ ‚àÉ'q) ‚ü∑ ‚àÉ'(ùóó p ‚ü∂ q) :=
by{ have : T ‚ä¢ ((‚àÉ'q) ‚äî ‚àºp) ‚ü∑ ‚àÉ'(q ‚äî ‚àºùóó p), by simpa using or_exists_pnf q ‚àºp,
    refine equiv_of_equiv this (equiv_symm impl_iff_or')
      (equiv_exists_of_equiv $ equiv_symm $ by simp)}

lemma exists_imply_pnf (p q) : T ‚ä¢ (‚àÉ'p ‚ü∂ q) ‚ü∑ ‚àÄ'(p ‚ü∂ ùóó q) :=
by{ have : T ‚ä¢ ((‚àÄ'‚àºp) ‚äî q) ‚ü∑ ‚àÄ'(‚àºp ‚äî ùóó q), by simp,
    refine equiv_of_equiv this _ _,
    { have : T ‚ä¢ (‚àº‚àº‚àÄ'‚àºp) ‚äî q ‚ü∑ ‚àÉ'p ‚ü∂ q, from equiv_symm (by simp[ex_def]),
      refine equiv_trans (equiv_or_of_equiv _ _) this; simp },
    { refine equiv_forall_of_equiv (equiv_symm $ by simp) } }

lemma forall_imply_pnf [Nonempty.extend T] (p q) : T ‚ä¢ (‚àÄ'p ‚ü∂ q) ‚ü∑ ‚àÉ'(p ‚ü∂ ùóó q) :=
by{ have : T ‚ä¢ ((‚àÉ'‚àºp) ‚äî q) ‚ü∑ ‚àÉ'(‚àºp ‚äî ùóó q), by simp,
    refine equiv_of_equiv this _ _,
    { have : T ‚ä¢ (‚àÉ'‚àºp) ‚äî q ‚ü∑ ‚àÄ'‚àº‚àºp ‚ü∂ q, from equiv_symm (by simp[ex_def]),
      refine equiv_trans this (equiv_imply_of_equiv (equiv_forall_of_equiv _) _); simp },
    { refine equiv_exists_of_equiv (equiv_symm $ by simp) } }

lemma forall_imply_forall_pnf [Nonempty.extend T] (p q) : T ‚ä¢ (‚àÄ'p ‚ü∂ ‚àÄ'q) ‚ü∑ ‚àÉ' ‚àÄ'(ùó° ùóó ùó† p ‚ü∂ ùóó q) :=
begin
  have : ùóü'T ‚ä¢ (ùó† p ‚ü∂ ‚àÄ'ùóü q) ‚ü∑ ‚àÄ'(ùóó ùó† p ‚ü∂ ùóü q), from imply_forall_pnf (ùó† p) (ùóü q),
  have lmm‚ÇÅ : T ‚ä¢ ‚àÉ'(p ‚ü∂ ‚àÄ' ùóó q) ‚ü∑ ‚àÉ' ‚àÄ'(ùó° ùóó ùó† p ‚ü∂ ùóó q),
    from equiv_exists_of_equiv (by simpa using this),
  have lmm‚ÇÇ : T ‚ä¢ (‚àÄ'p ‚ü∂ ‚àÄ'q) ‚ü∑ ‚àÉ'(p ‚ü∂ ‚àÄ' ùóó q), by simpa using forall_imply_pnf p (‚àÄ'q),
  exact equiv_trans lmm‚ÇÇ lmm‚ÇÅ
end

lemma forall_imply_exists_pnf [Nonempty.extend T] (p q) : T ‚ä¢ (‚àÄ'p ‚ü∂ ‚àÉ'q) ‚ü∑ ‚àÉ' ‚àÉ'(ùó° ùóó ùó† p ‚ü∂ ùóó q) :=
begin
  have : ùóü'T ‚ä¢ (ùó† p ‚ü∂ ‚àÉ'ùóü q) ‚ü∑ ‚àÉ'(ùóó ùó† p ‚ü∂ ùóü q), from imply_exists_pnf (ùó† p) (ùóü q),
  have lmm‚ÇÅ : T ‚ä¢ ‚àÉ'(p ‚ü∂ ‚àÉ' ùóó q) ‚ü∑ ‚àÉ' ‚àÉ'(ùó° ùóó ùó† p ‚ü∂ ùóó q),
    from equiv_exists_of_equiv (by simpa using this),
  have lmm‚ÇÇ : T ‚ä¢ (‚àÄ'p ‚ü∂ ‚àÉ'q) ‚ü∑ ‚àÉ'(p ‚ü∂ ‚àÉ' ùóó q), by simpa using forall_imply_pnf p (‚àÉ'q),
  exact equiv_trans lmm‚ÇÇ lmm‚ÇÅ
end

lemma exists_imply_forall_pnf (p q) : T ‚ä¢ (‚àÉ'p ‚ü∂ ‚àÄ'q) ‚ü∑ ‚àÄ' ‚àÄ'(ùó° ùóó ùó† p ‚ü∂ ùóó q) :=
begin
  have : ùóü'T ‚ä¢ (ùó† p ‚ü∂ ‚àÄ'ùóü q) ‚ü∑ ‚àÄ'(ùóó ùó† p ‚ü∂ ùóü q), from imply_forall_pnf (ùó† p) (ùóü q),
  have lmm‚ÇÅ : T ‚ä¢ ‚àÄ'(p ‚ü∂ ‚àÄ' ùóó q) ‚ü∑ ‚àÄ' ‚àÄ'(ùó° ùóó ùó† p ‚ü∂ ùóó q),
    from equiv_forall_of_equiv (by simpa using this),
  have lmm‚ÇÇ : T ‚ä¢ (‚àÉ'p ‚ü∂ ‚àÄ'q) ‚ü∑ ‚àÄ'(p ‚ü∂ ‚àÄ' ùóó q), by simpa using exists_imply_pnf p (‚àÄ'q),
  exact equiv_trans lmm‚ÇÇ lmm‚ÇÅ
end

lemma exists_imply_exists_pnf (p q) : T ‚ä¢ (‚àÉ'p ‚ü∂ ‚àÉ'q) ‚ü∑ ‚àÄ' ‚àÉ'(ùó° ùóó ùó† p ‚ü∂ ùóó q) :=
begin
  have : ùóü'T ‚ä¢ (ùó† p ‚ü∂ ‚àÉ'ùóü q) ‚ü∑ ‚àÉ'(ùóó ùó† p ‚ü∂ ùóü q), from imply_exists_pnf (ùó† p) (ùóü q),
  have lmm‚ÇÅ : T ‚ä¢ ‚àÄ'(p ‚ü∂ ‚àÉ' ùóó q) ‚ü∑ ‚àÄ' ‚àÉ'(ùó° ùóó ùó† p ‚ü∂ ùóó q),
    from equiv_forall_of_equiv (by simpa using this),
  have lmm‚ÇÇ : T ‚ä¢ (‚àÉ'p ‚ü∂ ‚àÉ'q) ‚ü∑ ‚àÄ'(p ‚ü∂ ‚àÉ' ùóó q), by simpa using exists_imply_pnf p (‚àÉ'q),
  exact equiv_trans lmm‚ÇÇ lmm‚ÇÅ
end

end prenex_normal_form

section quantifier
variables {m} {n : ‚Ñï}

lemma specialize_foralls (p : subformula L m n) (w : fin n ‚Üí subterm L m 0) : T ‚ä¢ ‚àÄ'*p ‚ü∂ substs w p :=
begin
  induction n with n IH generalizing m,
  { simp },
  { have : ùóü'T ‚ä¢ ‚àÄ'* ùó† p ‚ü∂ substs (mlift ‚àò w ‚àò fin.cast_succ) (ùó† p),
    from IH (ùó† p) (subterm.mlift ‚àò w ‚àò fin.cast_succ),
    have : T ‚ä¢ ‚àÄ'(ùó° (‚àÄ'*ùó† p) ‚ü∂ ùó° (substs (mlift ‚àò w ‚àò fin.cast_succ) (ùó† p))),
    by simpa using generalize this,
    have lmm‚ÇÅ : T ‚ä¢ ‚àÄ'*p ‚ü∂ ‚àÄ'ùó° (substs (mlift ‚àò w ‚àò fin.cast_succ) (ùó† p)),
    by simpa[forall_comm] using forallK _ _ ‚®Ä this,
    have lmm‚ÇÇ : T ‚ä¢ ‚àÄ'ùó° (substs (mlift ‚àò w ‚àò fin.cast_succ) (ùó† p)) ‚ü∂ substs w p,
    from specialize T (ùó° (substs (mlift ‚àò w ‚àò fin.cast_succ) (ùó† p))) (w $ fin.last n),
    exact imply_trans lmm‚ÇÅ lmm‚ÇÇ }
end

lemma foralls_substs {p : subformula L m n} (h : T ‚ä¢ ‚àÄ'*p) (w) : T ‚ä¢ substs w p :=
specialize_foralls p w ‚®Ä h

@[simp] lemma exists_dn (p : subformula L m n) : T ‚ä¢ ‚àÉ'*‚àº‚àºp ‚ü∑ ‚àÉ'*p :=
begin
  induction n with n IH generalizing m; simp[subformula.exists_comm],
  refine equiv_exists_of_equiv (by simpa using IH (ùó† p))
end

@[simp] lemma neg_univ_closure_neg (p : subformula L m n) : T ‚ä¢ ‚àº‚àÄ'*(‚àºp) ‚ü∑ ‚àÉ'*p :=
begin
  have : T ‚ä¢ ‚àº‚àÄ'*(‚àºp) ‚ü∑ ‚àÉ'*(‚àº‚àºp), from neg_univ_closure_pnf (‚àºp),
  refine equiv_trans this (by simp)
end

@[simp] lemma exists_substs (p : subformula L m n) (w : fin n ‚Üí subterm L m 0) : T ‚ä¢ substs w p ‚ü∂ ‚àÉ'*p :=
begin
  have : T ‚ä¢ ‚àº‚àºsubsts w p ‚ü∂ ‚àº‚àÄ'* (‚àºp), by simpa using contrapose.mpr (specialize_foralls (‚àºp) w),
  refine imply_of_equiv this (by simp) (by simp)
end

lemma exists_of_substs {p : subformula L m n} (w) (h : T ‚ä¢ substs w p) : T ‚ä¢ ‚àÉ'*p :=
exists_substs p w ‚®Ä h

end quantifier

end provable

namespace preTheory
variables {L m} (T U : preTheory L m)

--instance [T.extend U] : logic.Theory.extend T.mlift U.mlift := ‚ü®by { intros p h, sorry }‚ü©

end preTheory

section equal

def eq_axiom_schema_funext [L.has_equal] {m k} (f : L.fn k) : subformula L m 0 :=
‚àÄ'*((‚ãÄ i, #(fin.cast_add k i) =' #(fin.nat_add k i)) ‚ü∂
  (function f (var ‚àò fin.cast_add k) =' function f (var ‚àò fin.nat_add k)) : subformula L m (k + k))

def eq_axiom_schema_relext [L.has_equal] {m k} (r : L.pr k) : subformula L m 0 :=
‚àÄ'*((‚ãÄ i : fin k, #(fin.cast_add k i) =' #(fin.nat_add k i)) ‚ü∂
  (relation r (var ‚àò fin.cast_add k) ‚ü∑ relation r (var ‚àò fin.nat_add k)))

variables {L m} [language.has_equal L]

inductive Eq : preTheory L m
| eq_refl : Eq (‚àÄ'(#0 =' #0))
| eq_symm : Eq (‚àÄ' ‚àÄ'((#0 =' #1) ‚ü∂ (#1 =' #0)))
| eq_trans : Eq (‚àÄ' ‚àÄ' ‚àÄ'((#0 =' #1) ‚ü∂ (#1 =' #2) ‚ü∂ (#0 =' #2)))
| funext : ‚àÄ {k} (f : L.fn k), Eq (eq_axiom_schema_funext f)
| relext : ‚àÄ {k} (r : L.pr k), Eq (eq_axiom_schema_relext r)

attribute [simp] Eq.eq_refl Eq.eq_symm Eq.eq_trans Eq.funext Eq.relext

@[simp] lemma mlift_Eq : (Eq : preTheory L m).mlift = Eq :=
begin
  ext p, simp[preTheory.mlift], split,
  { rintros ‚ü®p, hp, rfl‚ü©,
    cases hp; simp[fal_eq],
    { exact Eq.eq_refl },
    { exact Eq.eq_symm },
    { exact Eq.eq_trans },
    { exact Eq.funext _ },
    { exact Eq.relext _ } },
  { intros h, cases h,
    { simp[fal_eq], refine ‚ü®_, Eq.eq_refl, by simp‚ü© },
    { simp[fal_eq], refine ‚ü®_, Eq.eq_symm, by simp‚ü© },
    { simp[fal_eq], refine ‚ü®_, Eq.eq_trans, by simp‚ü© },
    { refine ‚ü®_, Eq.funext _, by simp[eq_axiom_schema_funext]‚ü© },
    { refine ‚ü®_, Eq.relext _, by simp[eq_axiom_schema_relext, (‚àò)]‚ü© } }
end

--def eq_extend {T : preTheory L m} [extend Eq T] : extend Eq ùóü'T :=

end equal

end fol